---
title: "02-dereplicate-bruker-maldi-biotyper-spectra"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

Bacterial colony identification with the Bruker MALDI Biotyper is a high-throughput method with the built-in tools, provided that the selected bacteria belong to the internal database.

Scientific projects where the number of unknown bacteria is expected to be high needs reference-free methods to be able to reduce the redundancy of isolated bacterial colonies, a process called *dereplication*.

[Strejcek *et al.* (2018)](https://doi.org/10.3389/fmicb.2018.01294) proposed such a method by processing the spectra and suggest similarity thresholds between spectra above which spectra, and therefore the measured bacterial colonies, can be considered identical at a given taxonomic rank. Their processing procedure is implemented in the [`maldipickr`](https://github.com/ClavelLab/maldipickr) package and illustrated in the following vignette.

In addition, we provide functions to enable the dereplication of different batches of Bruker MALDI Biotyper runs and combine the results, in order to be able to delineate the clusters from a common similarity matrix.

More importantly, we provide a function to select a spectra to be picked in each cluster, a process called *cherry-picking*, depending on external metadata and potential out-groups to be excluded for the current cherry-picking steps.

# Process Bruker MALDI Biotyper spectra

From the imported raw data from the Bruker MALDI Biotyper, the processing of the spectra is based on the original implementation, and run the following tasks:

1. Square-root transformation
2. Mass range trimming to 4-10 kDa as they were deemed most determinant by Strejcek et al. (2018)
3. Signal smoothing using the Savitzky-Golay method and a half window size of 20
4. Baseline correction with the SNIP procedure
5. Normalisation by Total Ion Current
6. Peak detection using the SuperSmoother procedure and with a signal-to-noise ratio above 3
7. Peak filtering. This step has been added to discard peaks with a negative signal-to-noise ratio probably due to being on the edge of the mass range.

The full procedure is illustrated in the example below. While in this case, all the resulting processed spectra, peaks and final spectra metadata are stored in-memory, the `process_spectra` function enables storing these files locally for scalable high-throughput analyses.

```{r function-process_spectra}
#' Process Bruker MALDI Biotyper spectra _à la_ Strejcek et al. (2018)
#'
#' @details
#' Based on the original implementation, the function performs the following tasks:
#'
#' 1. Square-root transformation
#' 2. Mass range trimming to 4-10 kDa as they were deemed most determinant by Strejcek et al. (2018)
#' 3. Signal smoothing using the Savitzky-Golay method and a half window size of 20
#' 4. Baseline correction with the SNIP procedure
#' 5. Normalisation by Total Ion Current
#' 6. Peak detection using the SuperSmoother procedure and with a signal-to-noise ratio above 3
#' 7. Peak filtering. This step has been added to discard peaks with a negative signal-to-noise ratio probably due to being on the edge of the mass range.
#'
#'
#' @param spectra_list A list of [MALDIquant::MassSpectrum] objects.
#' @param rds_prefix A character indicating the prefix for the `.RDS` output files to be written in the `processed` directory. By default, no prefix are given and thus no files are written.
#'
#' @return A named list of three objects:
#' * `spectra`: a list the length of the spectra list of [MALDIquant::MassSpectrum] objects.
#' * `peaks`: a list the length of the spectra list of [MALDIquant::MassPeaks] objects.
#' * `metadata`: a tibble indicating the median signal-to-noise ratio (`SNR`) and peaks number for all spectra list (`peaks`), with spectra names in the `name` column.
#' @export
#'
#' @references Strejcek, Michal, Tereza Smrhova, Petra Junkova, and Ondrej Uhlik. “Whole-Cell MALDI-TOF MS versus 16S rRNA Gene Analysis for Identification and Dereplication of Recurrent Bacterial Isolates.” *Frontiers in Microbiology* 9 (2018). <https://doi.org/10.3389/fmicb.2018.01294>.
#'
#' @seealso [import_biotyper_spectra]
#' @note The original R code on which this function is based is accessible at: <https://github.com/strejcem/MALDIvs16S>
#' @examples
process_spectra <- function(spectra_list, rds_prefix = NULL) {
  # It returns the list and write it for future processing as an RDS file.

  # 1. SQRT transformation
  # 2. Mass range trimming
  # 3. Signal smoothing
  # 4. Baseline Correction
  # 5. Normalisation
  spectra <- spectra_list %>%
    MALDIquant::transformIntensity("sqrt") %>%
    MALDIquant::trim(range = c(4000, 10000)) %>%
    MALDIquant::smoothIntensity("SavitzkyGolay", halfWindowSize = 20) %>%
    MALDIquant::removeBaseline("SNIP", iterations = 50) %>%
    MALDIquant::calibrateIntensity(method = "TIC")

  # 6. Peak detection
  peaks <- spectra %>%
    MALDIquant::detectPeaks(
      method = "SuperSmoother",
      halfWindowSize = 20,
      SNR = 3
    )
  # Added extra step to remove the peaks with
  # negative SNR due to being on the edge of the masses trimmed
  peaks <- sapply(peaks, function(pk) {
    pk[MALDIquant::snr(pk) >= 3]
  })

  # Spectrum metadata table
  # Extract signal-to-noise ratios and peaks number
  metadata <- as.data.frame(t(sapply(peaks, function(x) {
    c(
      "SNR" = stats::median(MALDIquant::snr(x)),
      "peaks" = length(MALDIquant::snr(x))
    )
  })))

  # Add the spectra identifiers to all objects
  rownames(metadata) <- names(spectra) <- names(peaks) <- sapply(spectra, function(x) {
    # e.g., 230117_1750_1_B1
    gsub(
      "[-\\.]", "_",
      MALDIquant::metaData(x)[["fullName"]]
    )
  })
  # Aggregate the objects to a list
  processed_list <- list(
    "spectra" = spectra,
    "peaks" = peaks,
    # convert the data.frame to a tibble
    "metadata" = tibble::as_tibble(metadata, rownames = "name")
  )

  # Optional: writing objects to RDS files
  if (!is.null(rds_prefix)) {
    if (!dir.exists("processed")) {
      dir.create("processed")
    }
    saveRDS(processed_list,
      version = 2, compress = FALSE,
      file = paste0("processed/", rds_prefix, ".RDS")
    )
  }
  return(processed_list)
}
```

```{r examples-process_spectra}
# Get an example directory of six Bruker MALDI Biotyper spectra
directory_for_biotyper_spectra <- system.file("toy-species-spectra", package = "maldipickr")
# Import the six spectra
spectra_list <- import_biotyper_spectra(directory_for_biotyper_spectra)
# Transform the spectra signals according to Strejcek et al. (2018)
processed <- process_spectra(spectra_list)
# Overview of the list architecture that is returned
#  with the list of processed spectra, peaks identified and the
#  metadata table
str(processed, max.level = 2)
# A detailed view of the metadata with the median signal-to-noise
#  ratio (SNR) and the number of peaks
processed$metadata
```

```{r tests-process_spectra}
directory_for_biotyper_spectra <- system.file("toy-species-spectra", package = "maldipickr")
spectra_list_test <- import_biotyper_spectra(directory_for_biotyper_spectra)[1:2]
test_that("process_spectra works", {
  expect_equal(
    process_spectra(spectra_list_test)$metadata,
    structure(
      list(
        name = c("species1_G2", "species2_E11"),
        SNR = c(5.08959045014141, 5.54373537030499),
        peaks = c(21, 22)
      ),
      row.names = c(NA, -2L),
      class = c("tbl_df", "tbl", "data.frame")
    )
  )
})
test_that("process_spectra warns on empty spectra", {
  expect_warning(
    process_spectra(c(MALDIquant::createMassSpectrum(0, 0))),
    "MassSpectrum object is empty"
  )
})
```

# Merge multiples processed spectra

During high-throughput analyses, multiples runs of Bruker MALDI Biotyper are expected resulting in several batches of spectra to be processed and compared.
While their processing is natively independent, and could natively be run in parallell, the integration of the batches for their comparison needs an additional step.

The `merge_processed_spectra` function aggregates the processed spectra and bins together the detected peaks, with a tolerance of `r format(.002*10^-6)` ppm. This binning step results in a $n\times p$ feature matrix (or intensity matrix), with $n$ rows for $n$ processed spectra (peakless spectra are discarded) and $p$ columns for the $p$ peaks masses.

By default, as in the Strejeck et al. (2018) procedure, the intensity values for spectra with missing peaks are interpolated from the processed spectra signal.
The current function enables the analyst to decide whether to interpolate the values or leave missing peaks as `NA` which would then be converted to an null intensity value.

```{r function-merge_processed_spectra}
#' Merge multiples processed spectra and peaks
#'
#' Aggregate multiple processed spectra, their associated peaks and metadata into a feature matrix and a concatenated metadata table.
#'
#' @param processed_spectra A [list] The processed spectra and associated peaks and metadata in two possible formats:
#' * A vector of character that are the list of RDS files produced by [process_spectra].
#' * A named list of in-memory objects (named `spectra`, `peaks`, `metadata`) produced by [process_spectra].
#' @param remove_peakless_spectra A logical indicating whether to discard the spectra without detected peaks.
#' @param interpolate_missing A logical indicating if intensity values for missing peaks should be interpolated from the processed spectra signal or left NA which would then be converted to 0.
#'
#' @return A *n*×*p* matrix, with *n* spectra as rows and *p* features as columns that are the peaks found in all the processed spectra.
#'
#' @seealso [process_spectra], the "Value" section in [MALDIquant::intensityMatrix]
#' @export
merge_processed_spectra <- function(processed_spectra, remove_peakless_spectra = TRUE, interpolate_missing = TRUE) {
  # Determine the type of input
  processed <- switch(typeof(processed_spectra),
    "character" = lapply(processed_spectra, readRDS),
    "list" = processed_spectra
  )
  peakless <- list()
  # List the spectra with no peaks detected and remove them
  if (remove_peakless_spectra) {
    peakless <- lapply( # Extract the metadata object from all element of the list
      processed, `[[`, "metadata"
    ) %>%
      lapply(function(mdata) {
        rownames(mdata)[mdata$peaks == 0]
      }) %>%
      unlist()
    if (length(peakless) > 0) {
      warning(
        "No peaks were detected in the following spectra, so they will be removed\n",
        paste(peakless, collapse = "\n"), "\n"
      )
    }
  }

  # 7. Bin peaks
  peaks <- lapply( # Extract the peaks object from all element of the list
    processed, `[[`, "peaks"
  ) %>% unlist()
  names_spectra <- names(peaks)
  if (remove_peakless_spectra & length(peakless) > 0) {
    peaks <- peaks[-which(names(peaks) %in% peakless)]
  }
  peaks <- MALDIquant::binPeaks(peaks, tolerance = .002, method = "strict")

  # 8. Feature matrix construction (peaks as columns and spectra as rows)
  if (interpolate_missing) {
    # This is the default in the Strejcek et al. (2018) procedure
    spectra_list <- lapply( # Extract the spectrum object from all element of the list
      processed, `[[`, "spectra"
    ) %>% unlist()

    if (remove_peakless_spectra & length(peakless) > 0) {
      spectra_list <- spectra_list[-which(names(spectra_list) %in% peakless)]
    }
    featureMatrix <- MALDIquant::intensityMatrix(peaks, spectra_list)
  } else {
    featureMatrix <- MALDIquant::intensityMatrix(peaks)
    featureMatrix[is.na(featureMatrix)] <- 0
  }
  # Adding the correct rownames fto the matrix
  if (remove_peakless_spectra & length(peakless) > 0) {
    rownames(featureMatrix) <- names_spectra[-which(names_spectra %in% peakless)]
  } else {
    rownames(featureMatrix) <- names_spectra
  }
  return(featureMatrix)
}
```
  
```{r example-merge_processed_spectra}
# Get an example directory of six Bruker MALDI Biotyper spectra
directory_for_biotyper_spectra <- system.file("toy-species-spectra", package = "maldipickr")
# Import the six spectra
spectra_list <- import_biotyper_spectra(directory_for_biotyper_spectra)
# Transform the spectra signals according to Strejcek et al. (2018)
processed <- process_spectra(spectra_list)
# Merge the spectra to produce the feature matrix
fm <- merge_processed_spectra(list(processed))
# The feature matrix has 6 spectra as rows and
#  35 peaks as columns
dim(fm)
# Notice the difference when the interpolation is turned off
fm_no_interpolation <- merge_processed_spectra(list(processed), interpolate_missing = FALSE)
sum(fm == 0) # 0
sum(fm_no_interpolation == 0) # 68
```
  
```{r tests-merge_processed_spectra}
directory_for_biotyper_spectra <- system.file("toy-species-spectra", package = "maldipickr")
spectra_list_test <- import_biotyper_spectra(directory_for_biotyper_spectra)[1:2]
processed_test <- process_spectra(spectra_list_test)
test_that("merge_processed_spectra works", {
  expect_equal(
    dim(merge_processed_spectra(list(processed_test))),
    c(2, 26)
  )
})
test_that("merge_processed_spectra fails with only empty peaks", {
  expect_error(
    list(
      createMassSpectrum(
        mass = 4500:5000,
        intensity = rep(0, 501),
        metaData = list(fullName = "foo")
      )
    ) %>% process_spectra() %>%
      list() %>% merge_processed_spectra(),
    "no list of MALDIquant::MassPeaks objects!"
  )
})
```

# Compute a similarity matrix between all processed spectra (not included)

Once all the batches of spectra have been processed together, we can use a distance metric to evaluate how close the spectra are to one another.
[Strejcek *et al.* (2018)](https://doi.org/10.3389/fmicb.2018.01294) recommend the *cosine* metric to compare the spectra and they use the fast implementation in the `coop` package.

While we do not provide specific functions to generate the similarity matrix, we illustrate below how it can be easily computed.
Note that the feature matrix from `merge_processed_spectra` has spectra as rows and peaks values as columns.
So to get a similarity matrix between spectra, the feature matrix must be transposed before cosine computation.

```
# Install the coop package
# install.packages("coop")

# Compute the similarity matrix on the transposed feature matrix
sim_matrix <- coop::cosine( t(fm) )
```

# Delineate clusters from a similarity matrix

When the similarity matrix is computed between all pairs of the studied spectra, the next step is to delineate clusters of spectra to dereplicate the measured bacterial colonies.

The `similarity_to_clusters` is agnostic of the similarity metric used, whether it is the cosine metric or the  Pearson product moment, provided that a numeric threshold relevant to the metric used is given.

Indeed, the matrix is transformed into a network without loops, where nodes are spectra and links exist between spectra only if the similarity between the spectra is **above** (or **equal to**) the threshold.
This representation allows to infer the clusters. A table summarises for each spectra, to which cluster number it was assigned to and the size of the cluster, which is the total number of spectra in the cluster.


```{r function-similarity_to_clusters}
#' Delineate clusters from a similarity matrix
#'
#' From a matrix of spectra similarity (e.g., with the cosine metric,
#' or Pearson product moment), infer the species clusters based on a
#' threshold **above** (or **equal to**) which spectra are considered alike.
#'
#' @param sim_matrix A *n*×*n* similarity matrix, with *n* the number of spectra. Columns should be named as the rows.
#' @param threshold A numeric value indicating the minimal similarity between two spectra. Adjust accordingly to the similarity metric used.
#'
#' @return A tibble of *n* rows for each spectra and 3 columns:
#' * `name`: the rownames of the similarity matrix indicating the spectra names
#' * `membership`: integers stating the cluster number to which the spectra belong to. It starts from 1 to _c_, the total number of clusters.
#' * `cluster_size`: integers indicating the total number of spectra in the corresponding cluster.
#'
#' @details The matrix is transformed into a network without loops,
#'  where nodes are spectra and links exist between spectra only if the similarity
#'  between the spectra is above the threshold.
#'
#'  The original idea comes from a [StackOverflow answer by the user
#'  ekstroem](https://stackoverflow.com/a/57613463). However, here the
#'  implementation differs in two way:
#'
#'  1. It relies on the connected components of the network instead of the fast greedy
#'   modularity algorithm.
#'  2. It uses [tidygraph::tidygraph-package] instead of [igraph::igraph-package]
#'  to stay within the tibble and tidyverse for consistency.
#'
#' @export
similarity_to_clusters <- function(sim_matrix, threshold) {
  if (!is.matrix(sim_matrix)) {
    stop("The similarity matrix is not a matrix.")
  }
  if (nrow(sim_matrix) != ncol(sim_matrix)) {
    stop("The similarity matrix is not square: nrow != ncol.")
  }
  if (is.null(rownames(sim_matrix)) || is.null(colnames(sim_matrix))) {
    stop("The similarity matrix has no rownames or colnames.")
  }
  if (any(rownames(sim_matrix) != colnames(sim_matrix))) {
    stop("The similarity matrix has no identical names.")
  }
  if (!is.numeric(threshold)) {
    stop("The threshold provided is not a numeric.")
  }
  # No loops
  diag(sim_matrix) <- 0
  # Spectra as nodes are connected only if similarity is above the threshold
  sim_matrix[sim_matrix < threshold] <- 0
  # Delineate clusters
  igraph::graph_from_adjacency_matrix(sim_matrix,
    mode = "directed",
    weighted = TRUE,
    diag = FALSE
  ) %>%
    tidygraph::as_tbl_graph() %>%
    tidygraph::activate("nodes") %>% # Working on the nodes not the edges
    dplyr::mutate( # Gather connected components
      "membership" = tidygraph::group_components()
    ) %>%
    dplyr::group_by(.data$membership) %>%
    tibble::as_tibble() %>% # to be able to export only the nodes tibble
    dplyr::mutate(
      "cluster_size" = dplyr::n()
    ) %>%
    dplyr::ungroup() %>%
    return()
}
```
  
```{r example-similarity_to_clusters}
# Toy similarity matrix between the six example spectra of
#  three species. The cosine metric is used and a value of
#  zero indicates dissimilar spectra and a value of one
#  indicates identical spectra.
cosine_similarity <- matrix(
  c(
    1, 0.79, 0.77, 0.99, 0.98, 0.98,
    0.79, 1, 0.98, 0.79, 0.8, 0.8,
    0.77, 0.98, 1, 0.77, 0.77, 0.77,
    0.99, 0.79, 0.77, 1, 1, 0.99,
    0.98, 0.8, 0.77, 1, 1, 1,
    0.98, 0.8, 0.77, 0.99, 1, 1
  ),
  nrow = 6,
  dimnames = list(
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    ),
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    )
  )
)
# Delineate clusters based on a 0.92 threshold applied
#  to the similarity matrix
similarity_to_clusters(cosine_similarity, threshold = 0.92)
```
  
```{r tests-similarity_to_clusters}
cosine_similarity <- matrix(
  c(
    1, 0.79, 0.77, 0.99, 0.98, 0.98,
    0.79, 1, 0.98, 0.79, 0.8, 0.8,
    0.77, 0.98, 1, 0.77, 0.77, 0.77,
    0.99, 0.79, 0.77, 1, 1, 0.99,
    0.98, 0.8, 0.77, 1, 1, 1,
    0.98, 0.8, 0.77, 0.99, 1, 1
  ),
  nrow = 6,
  dimnames = list(
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    ),
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    )
  )
)
test_that("similarity_to_clusters works", {
  expect_equal(
    nrow(similarity_to_clusters(cosine_similarity, 0.92)), 6
  )
  expect_equal(
    similarity_to_clusters(cosine_similarity, 0.92)$membership,
    c(1, 2, 2, 1, 1, 1)
  )
})
test_that("similarity_to_clusters fails with wrong input", {
  expect_error(
    similarity_to_clusters(cosine_similarity[, -1], 0.92),
    "not square"
  )
  expect_error(
    similarity_to_clusters(unname(cosine_similarity), 0.92),
    "no rownames or colnames."
  )
  expect_error(
    similarity_to_clusters(cosine_similarity, TRUE),
    "not a numeric"
  )
})
```
  
# Set a reference spectrum for each cluster
  
Once the table of clusters is generated from the similarity matrix, a reference spectrum can be assigned to each cluster.  

We choose to define high-quality spectra as representative spectra of the clusters using internal information. That is, representative spectra have, within their cluster, the highest median signal-to-noise ratio and then the highest number of detected peaks.

The function `set_reference_spectra` does not change the order of the cluster table but merely add an additional column `is_reference` to indicate if the corresponding spectrum is representative of the cluster. 
    
```{r function-set_reference_spectra}
#' Set a reference spectrum for each cluster
#'
#' Define a high-quality spectra as a representative
#' spectra of the cluster based on the highest median signal-to-noise ratio
#' and the number of detected peaks
#'
#'
#' @param cluster_df A tibble of *n* rows for each spectra produced by [similarity_to_clusters] function with at least the following columns:
#' * `name`: the rownames of the similarity matrix indicating the spectra names
#' * `membership`: integers stating the cluster number to which the spectra belong to. It starts from 1 to _c_, the total number of clusters.
#' * `cluster_size`: integers indicating the total number of spectra in the corresponding cluster.
#' @param metadata_df A tibble of *n* rows for each spectra produced by the [process_spectra] function with median signal-to-noise ratio (`SNR`), peaks number (`peaks`), and spectra names in the `name` column.
#'
#'
#' @return A merged tibble in the same order as `cluster_df` with both the columns of `cluster_df` and `metadata_df`, as well as a logical column `is_reference` indicating if the spectrum is the reference spectra of the cluster.
#'
#' @export
set_reference_spectra <- function(cluster_df, metadata_df) {
  # Checking the tibbles sizes
  if (base::nrow(cluster_df) != base::nrow(metadata_df)) {
    stop(
      "The tibbles do not have the same number of rows!",
      "Note: if multiple batches are included in 'cluster_df'",
      "consider combining the multiple associated metadata tables",
      "using 'dplyr::bind_rows()'."
    )
  }
  # Checking the tibbles columns
  if (any(!c("name", "membership", "cluster_size") %in% colnames(cluster_df))) {
    stop(
      "'cluster_df' lacks one of the following columns:",
      "name, membership, cluster_size"
    )
  }
  if (any(!c("name", "SNR", "peaks") %in% colnames(metadata_df))) {
    stop(
      "'metadata_df' lacks one of the following columns:",
      "name, SNR, peaks"
    )
  }
  # Merging cluster information and spectra/peaks metadata to select the
  # reference spectra
  cluster_df %>%
    # Keep track of the row order via a numeric id
    tibble::rowid_to_column() %>%
    dplyr::inner_join(metadata_df, by = "name") %>%
    # Make sure the sorting is done within groups
    dplyr::group_by(.data$membership) %>%
    dplyr::arrange(dplyr::desc(.data$SNR), dplyr::desc(.data$peaks), .by_group = TRUE) %>%
    # first() gives the name of the spectra so needs for an
    # extra step to convert to a logical vector
    dplyr::mutate(
      "is_reference" = dplyr::first(.data$name),
      "is_reference" = .data$is_reference == .data$name
    ) %>%
    dplyr::ungroup() %>%
    # Sort the tibble in the original order
    dplyr::arrange(.data$rowid) %>%
    dplyr::select(-c("rowid")) %>%
    return()
}
```
  
```{r example-set_reference_spectra}
# Get an example directory of six Bruker MALDI Biotyper spectra
# Import the six spectra and
# Transform the spectra signals according to Strejcek et al. (2018)
processed <- system.file("toy-species-spectra", package = "maldipickr") %>%
  import_biotyper_spectra() %>%
  suppressMessages() %>%
  process_spectra()

# Toy similarity matrix between the six example spectra of
#  three species. The cosine metric is used and a value of
#  zero indicates dissimilar spectra and a value of one
#  indicates identical spectra.
cosine_similarity <- matrix(
  c(
    1, 0.79, 0.77, 0.99, 0.98, 0.98,
    0.79, 1, 0.98, 0.79, 0.8, 0.8,
    0.77, 0.98, 1, 0.77, 0.77, 0.77,
    0.99, 0.79, 0.77, 1, 1, 0.99,
    0.98, 0.8, 0.77, 1, 1, 1,
    0.98, 0.8, 0.77, 0.99, 1, 1
  ),
  nrow = 6,
  dimnames = list(
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    ),
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    )
  )
)
# Delineate clusters based on a 0.92 threshold applied
#  to the similarity matrix
clusters <- similarity_to_clusters(cosine_similarity, threshold = 0.92)

# Set reference spectra with the toy example
set_reference_spectra(clusters, processed$metadata)
```
  
```{r tests-set_reference_spectra}
processed <- system.file("toy-species-spectra", package = "maldipickr") %>%
  import_biotyper_spectra() %>%
  suppressMessages() %>%
  process_spectra()
cosine_similarity <- matrix(
  c(
    1, 0.79, 0.77, 0.99, 0.98, 0.98,
    0.79, 1, 0.98, 0.79, 0.8, 0.8,
    0.77, 0.98, 1, 0.77, 0.77, 0.77,
    0.99, 0.79, 0.77, 1, 1, 0.99,
    0.98, 0.8, 0.77, 1, 1, 1,
    0.98, 0.8, 0.77, 0.99, 1, 1
  ),
  nrow = 6,
  dimnames = list(
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    ),
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    )
  )
)
clusters <- similarity_to_clusters(cosine_similarity, threshold = 0.92)
test_that("set_reference_spectra works", {
  expect_equal(
    set_reference_spectra(clusters, processed$metadata)$is_reference,
    c(FALSE, FALSE, TRUE, FALSE, TRUE, FALSE)
  )
})
test_that("set_reference_spectra fails with inadequate metadata", {
  expect_error(
    set_reference_spectra(clusters, processed$metadata[1:2, ]),
    "The tibbles do not have the same number of rows!"
  )
  expect_error(
    set_reference_spectra(clusters[, -2], processed$metadata),
    "lacks one of the following columns"
  )
  expect_error(
    set_reference_spectra(clusters, processed$metadata[, -2]),
    "lacks one of the following columns"
  )
})
```
  
  
# Import clusters results generated by SPeDE

Raw spectra can also be processed and clustered by another approach, named [`SPeDE`](https://doi.org/10.1128/mSystems.00437-19), developed by Dumolin et al. (2019).
The resulting dereplication step produces a comma separated table. The example below illustrates how to import this table into R to be consistent with the dereplication table generated within the [`maldipickr`](https://github.com/ClavelLab/maldipickr) package.
    
```{r function-import_spede_clusters}
#' Import clusters results generated by SPeDE
#'
#' Reformat the table output from the analysis of raw Bruker MALDI Biotyper
#' spectra by the SPeDE tool from Dumolin et al. (2019) to be consistent with the Strejcek et al. (2018) procedure followed
#' in the [maldipickr] package.
#'
#' @param path Path to the comma separated table generated by SPeDE
#'
#' @return A tibble with the following columns:
#'
#' * `name`: a character denoting the spectra name (all spaces, dashes and dots are replaced by underscores "_" in SPeDE)
#' * `membership`: integers stating the cluster number to which the spectra belong to. It starts from 1 to _c_, the total number of clusters.
#' * `cluster_size`: integers indicating the total number of spectra in the corresponding cluster.
#' * `quality`: a character indicating the spectra quality category by SPeDE, out of GREEN, ORANGE and RED.
#' * `is_reference`: a logical indicating whether the corresponding spectra is a reference spectra of the cluster.
#'
#' @seealso <https://github.com/LM-UGent/SPeDE>
#' @references Dumolin C, Aerts M, Verheyde B, Schellaert S, Vandamme T, Van Der Jeugt F, De Canck E, Cnockaert M, Wieme AD, Cleenwerck I, Peiren J, Dawyndt P, Vandamme P, & Carlier A. (2019). "Introducing SPeDE: High-Throughput Dereplication and Accurate Determination of Microbial Diversity from Matrix-Assisted Laser Desorption–Ionization Time of Flight Mass Spectrometry Data". *MSystems* 4(5). <doi:10.1128/msystems.00437-19>.
#' @export
import_spede_clusters <- function(path) {
  # Import the SPeDE csv table with only the columns planned to be used
  utils::read.csv(path) %>%
    dplyr::select(
      "SOURCE_FILE",
      "QUALITY",
      "REFERENCE",
      "REFERENCE_NUMBER"
    ) %>%
    # Discard the trailing "Not matched:" and  "Rejected spectra:" at the end of the csv
    dplyr::filter(!is.na(.data$REFERENCE_NUMBER)) %>%
    tibble::as_tibble() %>%
    # Sanitize the column names and variable types to the package convention
    dplyr::rename(c(
      "name" = "SOURCE_FILE",
      "membership" = "REFERENCE_NUMBER",
      "quality" = "QUALITY"
    )) %>%
    dplyr::mutate(
      "membership" = .data$membership + 1,
      "is_reference" = if_else(.data$REFERENCE == "Yes", TRUE, FALSE)
    ) %>%
    # Add the cluster_size
    group_by(.data$membership) %>%
    mutate("cluster_size" = dplyr::n()) %>%
    select("name", "membership", "cluster_size", "quality", "is_reference") %>%
    ungroup() %>%
    return()
}
```
  
```{r example-import_spede_clusters}
# Reformat the output from SPeDE table
# https://github.com/LM-UGent/SPeDE
import_spede_clusters(
  system.file("spede.csv", package = "maldipickr")
)
```
  
```{r tests-import_spede_clusters}
test_that("import_spede_clusters works", {
  expect_equal(
    nrow(import_spede_clusters(
      system.file("spede.csv", package = "maldipickr")
    )), 6
  )
})
test_that("import_spede_clusters is empty when no spectra where matched", {
  expect_equal(
    nrow(import_spede_clusters(
      system.file("spede-empty.csv", package = "maldipickr")
    )), 0
  )
})
```


# Cherry-pick Bruker MALDI Biotyper spectra
    
When isolating bacteria from an environment, experimenters want to be thorough but also work-, time- and cost-savvy. One approach is to reduce the redundancy of the bacterial isolates by analyzing their MALDI-TOF spectra from the Bruker Biotyper. All the steps previously described in this vignette consisted of processing the spectra to be able to pick only non-redundant spectra, using the `pick_spectra` function.

The function, as illustrated in the examples below, can pick spectra using different types of inputs:

* the reference spectra information that is present in the cluster table (after using `similarity_to_clusters` or  `import_spede_clusters` functions; see example 1)
* an external metadata table containing a variable (e.g., optical density, fluorescence) to be maximized (default) or minimized per cluster (see example 2)

Spectra, and clusters, can also be excluded from the cherry-picking decision, a procedure termed _masking_ here. We distinguish two types of mask that are implemented in the `pick_spectra` function:

* **soft mask** that discards the spectra only, if they correspond for instance to low-quality sample, negative control samples (see example 3)
* **hard mask** that discards the spectra _and their clusters_ (see example 4). This is particularly useful if some spectra have been previously picked. For instance, to exclude colonies grown and picked 24h after streaking when comparing with colonies grown for 72h.

Advanced users can also provide directly a cluster table with a custom sort by cluster to accommodate complex design.

Ultimately, the function delivers a table with as many rows as the cluster table with an additional logical column named `to_pick` to indicate whether the colony associated with the spectra should be picked (`TRUE`) or not picked (`FALSE`).

    
```{r function-pick_spectra}
#' Cherry-pick Bruker MALDI Biotyper spectra
#'
#' Using the clusters information, and potential additional metadata as external
#' criteria, spectra are labelled as to be picked for each cluster. Note that some
#' spectra and therefore clusters can be explicitly removed (_masked_)
#' from the picking decision if they have been previously picked
#' or should be discarded, using logical columns in the metadata table.
#' If no metadata are provided, the reference spectra of each cluster will be picked.
#'
#' @param cluster_df A tibble with clusters information
#' from the [similarity_to_clusters] or the [import_spede_clusters] function.
#' @param metadata_df Optional tibble with relevant metadata to guide the
#' picking process (e.g., OD600).
#' @param criteria_column Optional character indicating the column in `metadata_df`
#' to be used as a criteria.
#' @param hard_mask_column Column name in the `cluster_df` or `metadata_df` tibble indicating whether the spectra, ** and the clusters to which they belong** should be discarded (`TRUE`) or not (`FALSE`) before the picking decision.
#' @param soft_mask_column Column name in the `cluster_df` or `metadata_df` tibble indicating whether the spectra should be discarded (`TRUE`) or not (`FALSE`) before the picking decision.
#' @param is_descending_order Optional logical indicating whether to sort the `criteria_column` from the highest-to-lowest value (`TRUE`) or lowest-to-highest (`FALSE`).
#' @param is_sorted Optional logical to indicate that the `cluster_df` is
#' already sorted by cluster based on (usually multiple) internal criteria to
#' pick the first of each cluster. This flag is **overriden** if a `metadata_df`
#' is provided.
#'
#' @return A tibble with as many rows as `cluster_df` with an additional logical
#' column named `to_pick` to indicate whether the colony associated to the spectra
#' should be picked. If `metadata_df` is provided, then additional columns from
#' this tibble are added to the returned tibble.
#'
#' @export
pick_spectra <- function(
    cluster_df,
    metadata_df = NULL, criteria_column = NULL,
    hard_mask_column = NULL, soft_mask_column = NULL,
    is_descending_order = TRUE,
    is_sorted = FALSE) {
  # Check that:
  #  - the mandatory column describing the cluster are present
  #  - clusters have a reference spectra to be picked if no metadata are provided
  #  - when metadata (resp. a criteria column) is provided,
  #     a criteria column (resp. metadata) should be provided as well
  #  - when masking columns are indicated, the metadata tibble should be added
  #  - the spectra name in the metadata table are also present in the clusters table
  if (any(!c("name", "membership") %in% colnames(cluster_df))) {
    stop(
      "'cluster_df' lacks one of the following columns: name or membership"
    )
  }
  if (is.null(metadata_df) & !"is_reference" %in% colnames(cluster_df)) {
    stop(
      "No additional metadata are provided ('metadata_df' tibble is NULL)",
      " and there is no 'is_reference' column in the 'cluster_df' tibble.\n",
      "Please do one of the following strategy:\n",
      "    1. Either run the 'set_reference_spectra' or 'import_spede_clusters'",
      "       function beforehand to indicate a reference spectra\n",
      "    2. Provide a 'metadata' tibble\n"
    )
  }
  if (
    (!is.null(metadata_df) & is.null(criteria_column)) ||
      (is.null(metadata_df) & !is.null(criteria_column))
  ) {
    stop(
      "Additional metadata ('metadata_df' tibble) should be provided",
      " with a criteria column ('criteria_column') to be sorted.",
      "Please provide the two together."
    )
  }
  if (
    (is.null(metadata_df) & !is.null(hard_mask_column)) ||
      (is.null(metadata_df) & !is.null(soft_mask_column))
  ) {
    stop(
      "Masking column(s) ('hard'/'soft') require an additional",
      " metadata ('metadata_df')"
    )
  }
  if (any(!metadata_df$name %in% cluster_df$name)) {
    stop(
      "The spectra names in the metadata ('metadata_df' tibble) table",
      " do not match the names in the clusters table ('cluster_df')."
    )
  }
  # Warn that metadata table are prioritize over the 'is_sorted' flag
  if (is_sorted & !is.null(metadata_df)) {
    message(
      "The 'is_sorted' flag is set to TRUE, while a metadata table is",
      " provided. ",
      "Please note that the metadata table takes precedence and the cherry-picking",
      " step will rely on the 'criteria_column'."
    )
    # Set the flag to FALSE for consistency
    is_sorted <- FALSE
  }

  # Preparing the table by merging with the metadata if present
  #   and checking the presence of the columns

  # Keep the initial order of the rows
  cluster_df <- tibble::rowid_to_column(cluster_df, "rowid")
  # And a copy of the unchanged data.frame
  # orig_cluster_df <- dplyr::select(cluster_df, c("rowid", "name"))
  orig_cluster_df <- cluster_df

  if (!is.null(metadata_df)) {
    cluster_df <- cluster_df %>%
      dplyr::left_join(metadata_df, by = "name")
    # Update the copy of the unchanged data.frame
    orig_cluster_df <- cluster_df
    if (!is.null(criteria_column) & !criteria_column %in% colnames(cluster_df)) {
      stop(
        "The 'criteria_column' is not present in the merged tibble."
      )
    }
    if (!is.null(soft_mask_column)) {
      if (!soft_mask_column %in% colnames(cluster_df)) {
        stop(
          "The 'soft_mask_column' is not present in the merged tibble."
        )
      }
    }
    if (!is.null(hard_mask_column)) {
      if (!hard_mask_column %in% colnames(cluster_df)) {
        stop(
          "The 'hard_mask_column' is not present in the merged tibble."
        )
      }
    }

    # Hard mask: discard the spectra *and* their clusters
    # Soft mask: discard the spectra only

    # Soft mask
    if (!is.null(soft_mask_column)) {
      cluster_df <- cluster_df %>% filter(!.data[[soft_mask_column]])
    }
    # Hard masking is used to label a group that should be
    # discarded in the dereplication process and not be chosen
    # from:
    #  e.g. 24h in the 24h vs 48h comparison
    #  e.g. fast in the fast vs slow growers comparison
    if (!is.null(hard_mask_column)) {
      clusters_to_keep <- cluster_df %>%
        dplyr::group_by(.data$membership) %>%
        # 2. Label the clusters as to be discarded if they contain:
        #   spectra from the discard group
        #   or spectra from both group (meaning the cluster was picked already)
        dplyr::summarise(
          "n" = dplyr::n_distinct(.data[[hard_mask_column]]),
          "to_discard" = base::unique(.data[[hard_mask_column]]),
          .groups = "keep"
        ) %>%
        dplyr::filter(n == 1 & !.data$to_discard) %>%
        dplyr::pull(.data$membership)

      # Remove the clusters where picking is forbidden
      cluster_df <- dplyr::filter(cluster_df, .data$membership %in% clusters_to_keep)
    }
  }


  # Sort the spectra within each cluster using the provided metadata
  if (!is.null(metadata_df) & !is_sorted) {
    cluster_df <- cluster_df %>%
      dplyr::group_by(.data$membership)
    if (is_descending_order) {
      cluster_df <- dplyr::arrange(
        cluster_df, dplyr::desc(.data[[criteria_column]]),
        .by_group = TRUE
      )
    } else {
      cluster_df <- dplyr::arrange(
        cluster_df, .data[[criteria_column]],
        .by_group = TRUE
      )
    }
  }

  # Pick the reference spectra if no metadata are present
  if (is.null(metadata_df)) {
    cluster_df <- cluster_df %>%
      dplyr::mutate(
        "to_pick" = .data$is_reference
      )
  } else {
    # first() gives the name of the spectra so needs for an
    # extra step to convert to a logical vector
    cluster_df <- cluster_df %>%
      dplyr::mutate(
        "to_pick" = dplyr::first(.data$name),
        "to_pick" = .data$to_pick == .data$name
      )
  }
  # Merge with original tibble to keep potential masked/discarded spectra
  # and same row number and order
  # NA in 'to_pick' are replaced with FALSE in the case of discarded clusters

  cols <- base::intersect(
    colnames(cluster_df),
    colnames(orig_cluster_df)
  )
  cluster_df %>%
    dplyr::ungroup() %>%
    dplyr::right_join(orig_cluster_df, by = cols) %>%
    dplyr::mutate(
      "to_pick" = tidyr::replace_na(.data$to_pick, FALSE)
    ) %>%
    # Sort the tibble in the original order
    dplyr::arrange(.data$rowid) %>%
    dplyr::select(-c("rowid")) %>%
    return()
}
```
  
```{r example-pick_spectra}
# 0. Load a toy example of a tibble of clusters created by
#   the `similarity_to_clusters` function.
clusters <- readRDS(
  system.file("clusters_tibble.RDS",
    package = "maldipickr"
  )
)
# 1. By default and if no other metadata are provided,
#   the function picks reference spectra for each clusters.
pick_spectra(clusters)

# 2.1 Simulate OD600 values with uniform distribution
#  for each of the colonies we measured with
#  the Bruker MALDI Biotyper
set.seed(104)
metadata <- dplyr::transmute(
  clusters,
  name = name, OD600 = runif(n = nrow(clusters))
)
metadata

# 2.2 Pick the spectra based on the highest
#   OD600 value per cluster
pick_spectra(clusters, metadata, "OD600")

# 3.1 Say that the wells on the right side of the plate are
#   used for negative controls and should not be picked.
metadata <- metadata %>% mutate(
  well = gsub(".*[A-Z]([0-9]{1,2}$)", "\\1", name) %>%
    strtoi(),
  is_edge = is_well_on_edge(
    well_number = well, plate_layout = 96, edges = "right"
  )
)

# 3.2 Pick the spectra after discarding (or soft masking)
#   the spectra indicated by the `is_edge` column.
pick_spectra(clusters, metadata, "OD600",
  soft_mask_column = "is_edge"
)

# 4.1 Say that some spectra were picked before
#   (e.g., in the column F) in a previous experiment.
# We do not want to pick clusters with those spectra
#   included to limit redundancy.
metadata <- metadata %>% mutate(
  picked_before = grepl("_F", name)
)
# 4.2 Pick the spectra from clusters without spectra
#   labelled as `picked_before` (hard masking).
pick_spectra(clusters, metadata, "OD600",
  hard_mask_column = "picked_before"
)
```
  
```{r tests-pick_spectra}
clusters <- readRDS(system.file("clusters_tibble.RDS", package = "maldipickr"))
set.seed(104)
metadata <- dplyr::transmute(clusters, name = name, OD600 = runif(n = nrow(clusters))) %>%
  mutate(
    well = gsub(".*[A-Z]([0-9]{1,2}$)", "\\1", name) %>%
      strtoi(),
    is_edge = is_well_on_edge(
      well_number = well, plate_layout = 96, edges = "right"
    ),
    picked_before = grepl("_F", name)
  )
altered_metadata <- dplyr::mutate(metadata, name = gsub("species", "", name))
test_that("pick_spectra works", {
  expect_true(
    identical(
      pick_spectra(clusters)$is_reference,
      pick_spectra(clusters)$to_pick
    )
  )
  expect_equal(
    pick_spectra(clusters, metadata, "OD600")$to_pick,
    c(FALSE, TRUE, FALSE, TRUE, FALSE, FALSE)
  )
  expect_equal(
    pick_spectra(clusters, metadata, "OD600",
      is_descending_order = FALSE
    )$to_pick,
    c(FALSE, FALSE, TRUE, FALSE, FALSE, TRUE)
  )
  expect_equal(
    pick_spectra(clusters, metadata, "OD600",
      soft_mask_column = "is_edge"
    )$to_pick,
    c(FALSE, TRUE, FALSE, TRUE, FALSE, FALSE)
  )
  expect_equal(
    pick_spectra(clusters, metadata, "OD600",
      hard_mask_column = "picked_before"
    )$to_pick,
    c(FALSE, TRUE, FALSE, FALSE, FALSE, FALSE)
  )
  expect_equal(
    pick_spectra(clusters, is_sorted = TRUE)$to_pick,
    c(FALSE, FALSE, TRUE, FALSE, TRUE, FALSE)
  )
})
test_that("pick_spectra fails without metadata and column", {
  expect_error(
    pick_spectra(clusters[, -1]),
    "lacks one of the following columns"
  )
  expect_error(
    pick_spectra(clusters[, -6]),
    "No additional metadata are provided"
  )
  expect_error(
    pick_spectra(clusters, metadata),
    "Additional metadata"
  )
  expect_error(
    pick_spectra(clusters, altered_metadata, "OD600"),
    "The spectra names in the metadata"
  )
  expect_error(
    pick_spectra(clusters, metadata, "OD600",
      hard_mask_column = "NOT_IN_TIBBLE"
    ),
    "The 'hard_mask_column' is not present in the merged tibble."
  )
  expect_error(
    pick_spectra(clusters, hard_mask_column = "picked_before"),
    "Masking column"
  )
})
```
  

# References

* Dumolin C, Aerts M, Verheyde B, Schellaert S, Vandamme T, Van Der Jeugt F, De Canck E, Cnockaert M, Wieme AD, Cleenwerck I, Peiren J, Dawyndt P, Vandamme P, & Carlier A. (2019). "Introducing SPeDE: High-Throughput Dereplication and Accurate Determination of Microbial Diversity from Matrix-Assisted Laser Desorption–Ionization Time of Flight Mass Spectrometry Data". *MSystems* 4(5). <doi:10.1128/msystems.00437-19>.
* Strejcek M, Smrhova T, Junkova P & Uhlik O (2018). “Whole-Cell MALDI-TOF MS versus 16S rRNA Gene Analysis for Identification and Dereplication of Recurrent Bacterial Isolates.” *Frontiers in Microbiology* 9 <doi:10.3389/fmicb.2018.01294>.

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(
  flat_file = "dev/dereplicate-spectra.Rmd",
  vignette_name = c(
    "Dereplicate Bruker MALDI Biotyper spectra" = "B-dereplicate-bruker-maldi-biotyper-spectra"
  )
)
```
