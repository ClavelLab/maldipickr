---
title: "02-dereplicate-bruker-maldi-biotyper-spectra"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

Bacterial colony identification with the Bruker MALDI Biotyper is a high-throughput method with the built-in tools, provided that the selected bacteria belong to the internal database.

Scientific projects where the number of unknown bacteria is expected to be high needs reference-free methods to be able to reduce the redundancy of isolated bacterial colonies, a process called *dereplication*.

[Strejcek *et al.* (2018)](https://doi.org/10.3389/fmicb.2018.01294) proposed such a method by processing the spectra and suggest similarity thresholds between spectra above which spectra, and therefore the measured bacterial colonies, can be considered identical at a given taxonomic rank. Their processing procedure is implemented in the [`maldipickr`](https://github.com/cpauvert/maldipickr) package and illustrated in the following vignette.

In addition, we provide functions to enable the dereplication of different batches of Bruker MALDI Biotyper runs and combine the results, in order to be able to delineate the clusters from a common similarity matrix.

More importantly, we provide a function to select a spectra to be picked in each cluster, a process called *cherry-picking*, depending on external metadata and potential out-groups to be excluded for the current cherry-picking steps.

# Process Bruker MALDI Biotyper spectra

From the imported raw data from the Bruker MALDI Biotyper, the processing of the spectra is based on the original implementation, and run the following tasks:

1. Square-root transformation
2. Mass range trimming to 4-10 kDa as they were deemed most determinant by Strejcek et al. (2018)
3. Signal smoothing using the Savitzky-Golay method and a half window size of 20
4. Baseline correction with the SNIP procedure
5. Normalisation by Total Ion Current
6. Peak detection using the SuperSmoother procedure and with a signal-to-noise ratio above 3
7. Peak filtering. This step has been added to discard peaks with a negative signal-to-noise ratio probably due to being on the edge of the mass range.

The full procedure is illustrated in the example below. While in this case, all the resulting processed spectra, peaks and final spectra metadata are stored in-memory, the `process_spectra` function enables storing these files locally for scalable high-throughput analyses.

```{r function-process_spectra}
#' Process Bruker MALDI Biotyper spectra _à la_ Strejcek et al. (2018)
#'
#' @details
#' Based on the original implementation, the function performs the following tasks:
#'
#' 1. Square-root transformation
#' 2. Mass range trimming to 4-10 kDa as they were deemed most determinant by Strejcek et al. (2018)
#' 3. Signal smoothing using the Savitzky-Golay method and a half window size of 20
#' 4. Baseline correction with the SNIP procedure
#' 5. Normalisation by Total Ion Current
#' 6. Peak detection using the SuperSmoother procedure and with a signal-to-noise ratio above 3
#' 7. Peak filtering. This step has been added to discard peaks with a negative signal-to-noise ratio probably due to being on the edge of the mass range.
#'
#'
#' @param spectra_list A list of [MALDIquant::MassSpectrum] objects.
#' @param rds_prefix A character indicating the prefix for the `.RDS` output files to be written in the `processed` directory. By default, no prefix are given and thus no files are written.
#'
#' @return A named list of three objects:
#' * `spectra`: a list the length of the spectra list of [MALDIquant::MassSpectrum] objects.
#' * `peaks`: a list the length of the spectra list of [MALDIquant::MassPeaks] objects.
#' * `metadata`: a tibble indicating the median signal-to-noise ratio (`SNR`) and peaks number for all spectra list (`peaks`), with spectra names in the `name` column.
#' @export
#'
#' @references Strejcek, Michal, Tereza Smrhova, Petra Junkova, and Ondrej Uhlik. “Whole-Cell MALDI-TOF MS versus 16S rRNA Gene Analysis for Identification and Dereplication of Recurrent Bacterial Isolates.” *Frontiers in Microbiology* 9 (2018). <https://doi.org/10.3389/fmicb.2018.01294>.
#'
#' @seealso [import_biotyper_spectra]
#' @note The original R code on which this function is based is accessible at: <https://github.com/strejcem/MALDIvs16S>
#' @examples
process_spectra <- function(spectra_list, rds_prefix = NULL) {
  # It returns the list and write it for future processing as an RDS file.

  # 1. SQRT transformation
  # 2. Mass range trimming
  # 3. Signal smoothing
  # 4. Baseline Correction
  # 5. Normalisation
  spectra <- spectra_list %>%
    MALDIquant::transformIntensity("sqrt") %>%
    MALDIquant::trim(range = c(4000, 10000)) %>%
    MALDIquant::smoothIntensity("SavitzkyGolay", halfWindowSize = 20) %>%
    MALDIquant::removeBaseline("SNIP", iterations = 50) %>%
    MALDIquant::calibrateIntensity(method = "TIC")

  # 6. Peak detection
  peaks <- spectra %>%
    MALDIquant::detectPeaks(
      method = "SuperSmoother",
      halfWindowSize = 20,
      SNR = 3
    )
  # Added extra step to remove the peaks with
  # negative SNR due to being on the edge of the masses trimmed
  peaks <- sapply(peaks, function(pk) {
    pk[MALDIquant::snr(pk) >= 3]
  })

  # Spectrum metadata table
  # Extract signal-to-noise ratios and peaks number
  metadata <- as.data.frame(t(sapply(peaks, function(x) {
    c(
      "SNR" = stats::median(MALDIquant::snr(x)),
      "peaks" = length(MALDIquant::snr(x))
    )
  })))

  # Add the spectra identifiers to all objects
  rownames(metadata) <- names(spectra) <- names(peaks) <- sapply(spectra, function(x) {
    # e.g., 230117_1750_1_B1
    gsub(
      "[-\\.]", "_",
      MALDIquant::metaData(x)[["fullName"]]
    )
  })
  # Aggregate the objects to a list
  processed_list <- list(
    "spectra" = spectra,
    "peaks" = peaks,
    # convert the data.frame to a tibble
    "metadata" = tibble::as_tibble(metadata, rownames = "name")
  )

  # Optional: writing objects to RDS files
  if (!is.null(rds_prefix)) {
    if (!dir.exists("processed")) {
      dir.create("processed")
    }
    saveRDS(processed_list,
      version = 2, compress = FALSE,
      file = paste0("processed/", rds_prefix, ".RDS")
    )
  }
  return(processed_list)
}
```

```{r examples-process_spectra}
# Get an example directory of six Bruker MALDI Biotyper spectra
directory_for_biotyper_spectra <- system.file("toy-species-spectra", package = "maldipickr")
# Import the six spectra
spectra_list <- import_biotyper_spectra(directory_for_biotyper_spectra)
# Transform the spectra signals according to Strejcek et al. (2018)
processed <- process_spectra(spectra_list)
# Overview of the list architecture that is returned
#  with the list of processed spectra, peaks identified and the
#  metadata table
str(processed, max.level = 2)
# A detailed view of the metadata with the median signal-to-noise
#  ratio (SNR) and the number of peaks
processed$metadata
```

```{r tests-process_spectra}
directory_for_biotyper_spectra <- system.file("toy-species-spectra", package = "maldipickr")
spectra_list_test <- import_biotyper_spectra(directory_for_biotyper_spectra)[1:2]
test_that("process_spectra works", {
  expect_equal(
    process_spectra(spectra_list_test)$metadata,
    structure(
      list(
        name = c("species1_G2", "species2_E11"),
        SNR = c(5.08959045014141, 5.54373537030499),
        peaks = c(21, 22)
      ),
      row.names = c(NA, -2L),
      class = c("tbl_df", "tbl", "data.frame")
    )
  )
})
test_that("process_spectra warns on empty spectra", {
  expect_warning(
    process_spectra(c(MALDIquant::createMassSpectrum(0, 0))),
    "MassSpectrum object is empty"
  )
})
```

# Merge multiples processed spectra

During high-throughput analyses, multiples runs of Bruker MALDI Biotyper are expected resulting in several batches of spectra to be processed and compared.
While their processing is natively independent, and could natively be run in parallell, the integration of the batches for their comparison needs an additional step.

The `merge_processed_spectra` function aggregates the processed spectra and bins together the detected peaks, with a tolerance of `r format(.002*10^-6)` ppm. This binning step results in a $n\times p$ feature matrix (or intensity matrix), with $n$ rows for $n$ processed spectra (peakless spectra are discarded) and $p$ columns for the $p$ peaks masses.

By default, as in the Strejeck et al. (2018) procedure, the intensity values for spectra with missing peaks are interpolated from the processed spectra signal.
The current function enables the analyst to decide whether to interpolate the values or leave missing peaks as `NA` which would then be converted to an null intensity value.

```{r function-merge_processed_spectra}
#' Merge multiples processed spectra and peaks
#'
#' Aggregate multiple processed spectra, their associated peaks and metadata into a feature matrix and a concatenated metadata table.
#'
#' @param processed_spectra A [list] The processed spectra and associated peaks and metadata in two possible formats:
#' * A vector of character that are the list of RDS files produced by [process_spectra].
#' * A named list of in-memory objects (named `spectra`, `peaks`, `metadata`) produced by [process_spectra].
#' @param remove_peakless_spectra A logical indicating whether to discard the spectra without detected peaks.
#' @param interpolate_missing A logical indicating if intensity values for missing peaks should be interpolated from the processed spectra signal or left NA which would then be converted to 0.
#'
#' @return A *n*×*p* matrix, with $n$ spectra as rows and $p$ features as columns that are the peaks found in all the processed spectra.
#'
#' @seealso [process_spectra], the "Value" section in [MALDIquant::intensityMatrix]
#' @export
merge_processed_spectra <- function(processed_spectra, remove_peakless_spectra = TRUE, interpolate_missing = TRUE) {
  # Determine the type of input
  processed <- switch(typeof(processed_spectra),
    "character" = lapply(processed_spectra, readRDS),
    "list" = processed_spectra
  )
  peakless <- list()
  # List the spectra with no peaks detected and remove them
  if (remove_peakless_spectra) {
    peakless <- lapply( # Extract the metadata object from all element of the list
      processed, `[[`, "metadata"
    ) %>%
      lapply(function(mdata) {
        rownames(mdata)[mdata$peaks == 0]
      }) %>%
      unlist()
    if (length(peakless) > 0) {
      warning(
        "No peaks were detected in the following spectra, so they will be removed\n",
        paste(peakless, collapse = "\n"), "\n"
      )
    }
  }

  # 7. Bin peaks
  peaks <- lapply( # Extract the peaks object from all element of the list
    processed, `[[`, "peaks"
  ) %>% unlist()
  names_spectra <- names(peaks)
  if (remove_peakless_spectra & length(peakless) > 0) {
    peaks <- peaks[-which(names(peaks) %in% peakless)]
  }
  peaks <- MALDIquant::binPeaks(peaks, tolerance = .002, method = "strict")

  # 8. Feature matrix construction (peaks as columns and spectra as rows)
  if (interpolate_missing) {
    # This is the default in the Strejcek et al. (2018) procedure
    spectra_list <- lapply( # Extract the spectrum object from all element of the list
      processed, `[[`, "spectra"
    ) %>% unlist()

    if (remove_peakless_spectra & length(peakless) > 0) {
      spectra_list <- spectra_list[-which(names(spectra_list) %in% peakless)]
    }
    featureMatrix <- MALDIquant::intensityMatrix(peaks, spectra_list)
  } else {
    featureMatrix <- MALDIquant::intensityMatrix(peaks)
    featureMatrix[is.na(featureMatrix)] <- 0
  }
  # Adding the correct rownames fto the matrix
  if (remove_peakless_spectra & length(peakless) > 0) {
    rownames(featureMatrix) <- names_spectra[-which(names_spectra %in% peakless)]
  } else {
    rownames(featureMatrix) <- names_spectra
  }
  return(featureMatrix)
}
```
  
```{r example-merge_processed_spectra}
# Get an example directory of six Bruker MALDI Biotyper spectra
directory_for_biotyper_spectra <- system.file("toy-species-spectra", package = "maldipickr")
# Import the six spectra
spectra_list <- import_biotyper_spectra(directory_for_biotyper_spectra)
# Transform the spectra signals according to Strejcek et al. (2018)
processed <- process_spectra(spectra_list)
# Merge the spectra to produce the feature matrix
fm <- merge_processed_spectra(list(processed))
# The feature matrix has 6 spectra as rows and
#  35 peaks as columns
dim(fm)
# Notice the difference when the interpolation is turned off
fm_no_interpolation <- merge_processed_spectra(list(processed), interpolate_missing = FALSE)
sum(fm == 0) # 0
sum(fm_no_interpolation == 0) # 68
```
  
```{r tests-merge_processed_spectra}
directory_for_biotyper_spectra <- system.file("toy-species-spectra", package = "maldipickr")
spectra_list_test <- import_biotyper_spectra(directory_for_biotyper_spectra)[1:2]
processed_test <- process_spectra(spectra_list_test)
test_that("merge_processed_spectra works", {
  expect_equal(
    dim(merge_processed_spectra(list(processed_test))),
    c(2, 26)
  )
})
test_that("merge_processed_spectra fails with only empty peaks", {
  expect_error(
    list(
      createMassSpectrum(
        mass = 4500:5000,
        intensity = rep(0, 501),
        metaData = list(fullName = "foo")
      )
    ) %>% process_spectra() %>%
      list() %>% merge_processed_spectra(),
    "no list of MALDIquant::MassPeaks objects!"
  )
})
```

# Compute a similarity matrix between all processed spectra (not included)

Once all the batches of spectra have been processed together, we can use a distance metric to evaluate how close the spectra are to one another.
[Strejcek *et al.* (2018)](https://doi.org/10.3389/fmicb.2018.01294) recommend the *cosine* metric to compare the spectra and they use the fast implementation in the `coop` package.

While we do not provide specific functions to generate the similarity matrix, we illustrate below how it can be easily computed.
Note that the feature matrix from `merge_processed_spectra` has spectra as rows and peaks values as columns.
So to get a similarity matrix between spectra, the feature matrix must be transposed before cosine computation.

```
# Install the coop package
# install.packages("coop")

# Compute the similarity matrix on the transposed feature matrix
sim_matrix <- coop::cosine( t(fm) )
```

# Delineate clusters from a similarity matrix

When the similarity matrix is computed between all pairs of the studied spectra, the next step is to delineate clusters of spectra to dereplicate the measured bacterial colonies.

The `similarity_to_clusters` is agnostic of the similarity metric used, whether it is the cosine metric or the  Pearson product moment, provided that a numeric threshold relevant to the metric used is given.

Indeed, the matrix is transformed into a network without loops, where nodes are spectra and links exist between spectra only if the similarity between the spectra is **above** (or **equal to**) the threshold.
This representation allows to infer the clusters. A table summarises for each spectra, to which cluster number it was assigned to and the size of the cluster, which is the total number of spectra in the cluster.


```{r function-similarity_to_clusters}
#' Delineate clusters from a similarity matrix
#'
#' From a matrix of spectra similarity (e.g., with the cosine metric,
#' or Pearson product moment), infer the species clusters based on a
#' threshold **above** (or **equal to**) which spectra are considered alike.
#'
#' @param sim_matrix A *n*×*n* similarity matrix, with *n* the number of spectra. Columns should be named as the rows.
#' @param threshold A numeric value indicating the minimal similarity between two spectra. Adjust accordingly to the similarity metric used.
#'
#' @return A tibble of *n* rows for each spectra and 3 columns:
#' * `name`: the rownames of the similarity matrix indicating the spectra names
#' * `membership`: integers stating the cluster number to which the spectra belong to. It starts from 1 to _c_, the total number of clusters.
#' * `cluster_size`: integers indicating the total number of spectra in the corresponding cluster.
#'
#' @details The matrix is transformed into a network without loops,
#'  where nodes are spectra and links exist between spectra only if the similarity
#'  between the spectra is above the threshold.
#'
#'  The original idea comes from a [StackOverflow answer by the user
#'  ekstroem](https://stackoverflow.com/a/57613463). However, here the
#'  implementation differs in two way:
#'
#'  1. It relies on the connected components of the network instead of the fast greedy
#'   modularity algorithm.
#'  2. It uses [tidygraph::tidygraph-package] instead of [igraph::igraph-package]
#'  to stay within the tibble and tidyverse for consistency.
#'
#' @export
similarity_to_clusters <- function(sim_matrix, threshold) {
  if (!is.matrix(sim_matrix)) {
    stop("The similarity matrix is not a matrix.")
  }
  if (nrow(sim_matrix) != ncol(sim_matrix)) {
    stop("The similarity matrix is not square: nrow != ncol.")
  }
  if (is.null(rownames(sim_matrix)) || is.null(colnames(sim_matrix))) {
    stop("The similarity matrix has no rownames or colnames.")
  }
  if (any(rownames(sim_matrix) != colnames(sim_matrix))) {
    stop("The similarity matrix has no identical names.")
  }
  if (!is.numeric(threshold)) {
    stop("The threshold provided is not a numeric.")
  }
  # No loops
  diag(sim_matrix) <- 0
  # Spectra as nodes are connected only if similarity is above the threshold
  sim_matrix[sim_matrix < threshold] <- 0
  # Delineate clusters
  igraph::graph_from_adjacency_matrix(sim_matrix,
    mode = "directed",
    weighted = TRUE,
    diag = FALSE
  ) %>%
    tidygraph::as_tbl_graph() %>%
    tidygraph::activate("nodes") %>% # Working on the nodes not the edges
    dplyr::mutate( # Gather connected components
      "membership" = tidygraph::group_components()
    ) %>%
    dplyr::group_by(.data$membership) %>%
    tibble::as_tibble() %>% # to be able to export only the nodes tibble
    dplyr::mutate(
      "cluster_size" = dplyr::n()
    ) %>%
    dplyr::ungroup() %>%
    return()
}
```
  
```{r example-similarity_to_clusters}
# Toy similarity matrix between the six example spectra of
#  three species. The cosine metric is used and a value of
#  zero indicates dissimilar spectra and a value of one
#  indicates identical spectra.
cosine_similarity <- matrix(
  c(
    1, 0.79, 0.77, 0.99, 0.98, 0.98,
    0.79, 1, 0.98, 0.79, 0.8, 0.8,
    0.77, 0.98, 1, 0.77, 0.77, 0.77,
    0.99, 0.79, 0.77, 1, 1, 0.99,
    0.98, 0.8, 0.77, 1, 1, 1,
    0.98, 0.8, 0.77, 0.99, 1, 1
  ),
  nrow = 6,
  dimnames = list(
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    ),
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    )
  )
)
# Delineate clusters based on a 0.92 threshold applied
#  to the similarity matrix
similarity_to_clusters(cosine_similarity, threshold = 0.92)
```
  
```{r tests-similarity_to_clusters}
cosine_similarity <- matrix(
  c(
    1, 0.79, 0.77, 0.99, 0.98, 0.98,
    0.79, 1, 0.98, 0.79, 0.8, 0.8,
    0.77, 0.98, 1, 0.77, 0.77, 0.77,
    0.99, 0.79, 0.77, 1, 1, 0.99,
    0.98, 0.8, 0.77, 1, 1, 1,
    0.98, 0.8, 0.77, 0.99, 1, 1
  ),
  nrow = 6,
  dimnames = list(
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    ),
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    )
  )
)
test_that("similarity_to_clusters works", {
  expect_equal(
    nrow(similarity_to_clusters(cosine_similarity, 0.92)), 6
  )
  expect_equal(
    similarity_to_clusters(cosine_similarity, 0.92)$membership,
    c(1, 2, 2, 1, 1, 1)
  )
})
test_that("similarity_to_clusters fails with wrong input", {
  expect_error(
    similarity_to_clusters(cosine_similarity[, -1], 0.92),
    "not square"
  )
  expect_error(
    similarity_to_clusters(unname(cosine_similarity), 0.92),
    "no rownames or colnames."
  )
  expect_error(
    similarity_to_clusters(cosine_similarity, TRUE),
    "not a numeric"
  )
})
```
  
  
# Import clusters results generated by SPeDE
    
```{r function-import_spede_clusters}
#' Import clusters results generated by SPeDE
#'
#' Reformat the table output from the analysis of raw Bruker MALDI Biotyper
#' spectra by the SPeDE tool to be consistent with the Strejcek et al. (2018) procedure followed
#' in the [maldipickr] package.
#'
#' @param path Path to the comma separated table generated by SPeDE
#'
#' @return A tibble with the following columns:
#'
#' * `name`: a character denoting the spectra name (all spaces, dashes and dots are replaced by underscores "_" in SPeDE)
#' * `membership`: integers stating the cluster number to which the spectra belong to. It starts from 1 to _c_, the total number of clusters.
#' * `cluster_size`: integers indicating the total number of spectra in the corresponding cluster.
#' * `quality`: a character indicating the spectra quality category by SPeDE, out of GREEN, ORANGE and RED.
#' * `is_reference`: a logical indicating whether the corresponding spectra is a reference spectra of the cluster.
#'
#' @export
import_spede_clusters <- function(path) {
  # Import the SPeDE csv table with only the columns planned to be used
  utils::read.csv(path) %>%
    dplyr::select(
      "SOURCE_FILE",
      "QUALITY",
      "REFERENCE",
      "REFERENCE_NUMBER"
    ) %>%
    # Discard the trailing "Not matched:" and  "Rejected spectra:" at the end of the csv
    dplyr::filter(!is.na(.data$REFERENCE_NUMBER)) %>%
    tibble::as_tibble() %>%
    # Sanitize the column names and variable types to the package convention
    dplyr::rename(c(
      "name" = "SOURCE_FILE",
      "membership" = "REFERENCE_NUMBER",
      "quality" = "QUALITY"
    )) %>%
    dplyr::mutate(
      "membership" = .data$membership + 1,
      "is_reference" = if_else(.data$REFERENCE == "Yes", TRUE, FALSE)
    ) %>%
    # Add the cluster_size
    group_by(.data$membership) %>%
    mutate("cluster_size" = dplyr::n()) %>%
    select("name", "membership", "cluster_size", "quality", "is_reference") %>%
    ungroup() %>%
    return()
}
```
  
```{r example-import_spede_clusters}
import_spede_clusters(
  system.file("spede.csv", package = "maldipickr")
)
```
  
```{r tests-import_spede_clusters}
test_that("import_spede_clusters works", {
  expect_equal(
    nrow(import_spede_clusters(
      system.file("spede.csv", package = "maldipickr")
    )), 6
  )
})
test_that("import_spede_clusters is empty when no spectra where matched", {
  expect_equal(
    nrow(import_spede_clusters(
      system.file("spede-empty.csv", package = "maldipickr")
    )), 0
  )
})
```
  

# References

* Strejcek M, Smrhova T, Junkova P & Uhlik O (2018). “Whole-Cell MALDI-TOF MS versus 16S rRNA Gene Analysis for Identification and Dereplication of Recurrent Bacterial Isolates.” *Frontiers in Microbiology* 9 <https://doi.org/10.3389/fmicb.2018.01294>.

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(
  flat_file = "dev/dereplicate-spectra.Rmd",
  vignette_name = c(
    "Dereplicate Bruker MALDI Biotyper spectra" = "02-dereplicate-bruker-maldi-biotyper-spectra"
  )
)
```
