---
title: "Dereplicate Bruker MALDI Biotyper spectra"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

Bacterial colony identification with the Bruker MALDI Biotyper is a high-throughput method with the built-in tools, provided that the selected bacteria belong to the internal database.

Scientific projects where the number of unknown bacteria is expected to be high needs reference-free methods to be able to reduce the redundancy of isolated bacterial colonies, a process called *dereplication*.

[Strejcek *et al.* (2018)](https://doi.org/10.3389/fmicb.2018.01294) proposed such a method by processing the spectra and suggest similarity thresholds between spectra above which spectra, and therefore the measured bacterial colonies, can be considered identical at a given taxonomic rank. Their processing procedure is implemented in the [`{maldipickr}`](https://github.com/ClavelLab/maldipickr) package and illustrated in the following vignette.

In addition, we provide functions to enable the dereplication of different batches of Bruker MALDI Biotyper runs and combine the results, in order to be able to delineate the clusters from a common similarity matrix.

More importantly, we provide a function to select a spectra to be picked in each cluster, a process called *cherry-picking*, depending on external metadata and potential out-groups to be excluded for the current cherry-picking steps.

# Process Bruker MALDI Biotyper spectra

## Process from raw spectra to peak filtering

From the imported raw data from the Bruker MALDI Biotyper, the processing of the spectra is based on the original implementation, and run the following tasks:

1. Square-root transformation
2. Mass range trimming to 4-10 kDa as they were deemed most determinant by Strejcek et al. (2018)
3. Signal smoothing using the Savitzky-Golay method and a half window size of 20
4. Baseline correction with the SNIP procedure
5. Normalization by Total Ion Current
6. Peak detection using the SuperSmoother procedure and with a signal-to-noise ratio above 3
7. Peak filtering. This step has been added to discard peaks with a negative signal-to-noise ratio probably due to being on the edge of the mass range.

The full procedure is illustrated in the example below. While in this case, all the resulting processed spectra, peaks and final spectra metadata are stored in-memory, the [`process_spectra()`](https://clavellab.github.io/maldipickr/reference/process_spectra.html) function enables storing these files locally for scalable high-throughput analyses.

```{r function-process_spectra}
#' Process Bruker MALDI Biotyper spectra _à la_ Strejcek et al. (2018)
#'
#' @details
#' Based on the original implementation, the function performs the following tasks:
#'
#' 1. Square-root transformation
#' 2. Mass range trimming to 4-10 kDa as they were deemed most determinant by Strejcek et al. (2018)
#' 3. Signal smoothing using the Savitzky-Golay method and a half window size of 20
#' 4. Baseline correction with the SNIP procedure
#' 5. Normalization by Total Ion Current
#' 6. Peak detection using the SuperSmoother procedure and with a signal-to-noise ratio above 3
#' 7. Peak filtering. This step has been added to discard peaks with a negative signal-to-noise ratio probably due to being on the edge of the mass range.
#'
#'
#' @param spectra_list A list of [MALDIquant::MassSpectrum] objects.
#' @param rds_prefix A character indicating the prefix for the `.RDS` output files to be written in the `processed` directory. By default, no prefix are given and thus no files are written.
#'
#' @return A named list of three objects:
#' * `spectra`: a list the length of the spectra list of [MALDIquant::MassSpectrum] objects.
#' * `peaks`: a list the length of the spectra list of [MALDIquant::MassPeaks] objects.
#' * `metadata`: a tibble indicating the median signal-to-noise ratio (`SNR`) and peaks number for all spectra list (`peaks`), with spectra names in the `name` column.
#'
#' @seealso [import_biotyper_spectra] and [check_spectra] for the inputs and [merge_processed_spectra] for further analysis.
#' @export
#'
#' @references Strejcek M, Smrhova T, Junkova P & Uhlik O (2018). “Whole-Cell MALDI-TOF MS versus 16S rRNA Gene Analysis for Identification and Dereplication of Recurrent Bacterial Isolates.” *Frontiers in Microbiology* 9 <doi:10.3389/fmicb.2018.01294>.
#'
#' @note The original R code on which this function is based is accessible at: <https://github.com/strejcem/MALDIvs16S>
#' @examples
process_spectra <- function(spectra_list, rds_prefix = NULL) {
  # It returns the list and write it for future processing as an RDS file.

  # 1. SQRT transformation
  # 2. Mass range trimming
  # 3. Signal smoothing
  # 4. Baseline Correction
  # 5. Normalization
  spectra <- spectra_list %>%
    MALDIquant::transformIntensity("sqrt") %>%
    MALDIquant::trim(range = c(4000, 10000)) %>%
    MALDIquant::smoothIntensity("SavitzkyGolay", halfWindowSize = 20) %>%
    MALDIquant::removeBaseline("SNIP", iterations = 50) %>%
    MALDIquant::calibrateIntensity(method = "TIC")

  # 6. Peak detection
  peaks <- spectra %>%
    MALDIquant::detectPeaks(
      method = "SuperSmoother",
      halfWindowSize = 20,
      SNR = 3
    )
  # Added extra step to remove the peaks with
  # negative SNR due to being on the edge of the masses trimmed
  peaks <- sapply(peaks, function(pk) {
    pk[MALDIquant::snr(pk) >= 3]
  })

  # Spectrum metadata table
  # Extract signal-to-noise ratios and peaks number
  metadata <- as.data.frame(t(sapply(peaks, function(x) {
    c(
      "SNR" = stats::median(MALDIquant::snr(x)),
      "peaks" = length(MALDIquant::snr(x))
    )
  })))

  # Add the spectra identifiers to all objects
  rownames(metadata) <- names(spectra) <- names(peaks) <- sapply(spectra, function(x) {
    # e.g., 230117_1750_1_B1
    gsub(
      "[-\\.]", "_",
      MALDIquant::metaData(x)[["fullName"]]
    )
  })
  # Aggregate the objects to a list
  processed_list <- list(
    "spectra" = spectra,
    "peaks" = peaks,
    # convert the data.frame to a tibble
    "metadata" = tibble::as_tibble(metadata, rownames = "name")
  )

  # Optional: writing objects to RDS files
  if (!is.null(rds_prefix)) {
    if (!dir.exists("processed")) {
      dir.create("processed")
    }
    saveRDS(processed_list,
      version = 2, compress = FALSE,
      file = paste0("processed/", rds_prefix, ".RDS")
    )
  }
  return(processed_list)
}
```

```{r examples-process_spectra}
# Get an example directory of six Bruker MALDI Biotyper spectra
directory_biotyper_spectra <- system.file(
  "toy-species-spectra",
  package = "maldipickr"
)
# Import the six spectra
spectra_list <- import_biotyper_spectra(directory_biotyper_spectra)
# Transform the spectra signals according to Strejcek et al. (2018)
processed <- process_spectra(spectra_list)
# Overview of the list architecture that is returned
#  with the list of processed spectra, peaks identified and the
#  metadata table
str(processed, max.level = 2)
# A detailed view of the metadata with the median signal-to-noise
#  ratio (SNR) and the number of peaks
processed$metadata
```

```{r tests-process_spectra}
directory_biotyper_spectra <- system.file("toy-species-spectra", package = "maldipickr")
spectra_list_test <- import_biotyper_spectra(directory_biotyper_spectra)[1:2]
test_that("process_spectra works", {
  expect_equal(
    process_spectra(spectra_list_test)$metadata,
    structure(
      list(
        name = c("species1_G2", "species2_E11"),
        SNR = c(5.08959045014141, 5.54373537030499),
        peaks = c(21, 22)
      ),
      row.names = c(NA, -2L),
      class = c("tbl_df", "tbl", "data.frame")
    )
  )
})
test_that("process_spectra warns on empty spectra", {
  expect_warning(
    process_spectra(c(MALDIquant::createMassSpectrum(0, 0))),
    "MassSpectrum object is empty"
  )
})
```

## Merge multiple processed spectra

During high-throughput analyses, multiples runs of Bruker MALDI Biotyper are expected resulting in several batches of spectra to be processed and compared.
While their processing is natively independent, and could natively be run in parallel, the integration of the batches for their comparison needs an additional step.

The [`merge_processed_spectra()`](https://clavellab.github.io/maldipickr/reference/merge_processed_spectra.html) function aggregates the processed spectra and bins together the detected peaks, with a tolerance of $0.002$ between the average peak values in the bin (see [`MALDIquant::binPeaks`](https://rdrr.io/cran/MALDIquant/man/binPeaks-functions.html)), which translate to a tolerance of `r format(.002/10^-6)` ppm. This binning step results in a $n\times p$ feature matrix (or intensity matrix), with $n$ rows for $n$ processed spectra (peak-less spectra are discarded) and $p$ columns for the $p$ peaks masses.

By default, as in the Strejeck et al. (2018) procedure, the intensity values for spectra with missing peaks are interpolated from the processed spectra signal.
The current function enables the analyst to decide whether to interpolate the values or leave missing peaks as `NA` which would then be converted to an null intensity value.

```{r function-merge_processed_spectra}
#' Merge multiple processed spectra and peaks
#'
#' Aggregate multiple processed spectra, their associated peaks and metadata into a feature matrix and a concatenated metadata table.
#'
#' @param processed_spectra A [list] of the processed spectra and associated peaks and metadata in two possible formats:
#' * A list of **paths** to RDS files produced by [process_spectra] when using the `rds_prefix` option.
#' * A list of **in-memory objects** (named `spectra`, `peaks`, `metadata`) produced by [process_spectra].
#' @param remove_peakless_spectra A logical indicating whether to discard the spectra without detected peaks.
#' @param interpolate_missing A logical indicating if intensity values for missing peaks should be interpolated from the processed spectra signal or left NA which would then be converted to 0.
#'
#' @return A *n*×*p* matrix, with *n* spectra as rows and *p* features as columns that are the peaks found in all the processed spectra.
#'
#' @seealso [process_spectra], the "Value" section in [`MALDIquant::intensityMatrix`](https://rdrr.io/cran/MALDIquant/man/intensityMatrix-functions.html)
#' @export
merge_processed_spectra <- function(processed_spectra, remove_peakless_spectra = TRUE, interpolate_missing = TRUE) {
  if (any(
    is.null(processed_spectra),
    !is.list(processed_spectra),
    length(processed_spectra) == 0
  )
  ) {
    stop(
      "Either 'processed_spectra' is not a list or it is an empty list."
    )
  }
  # Determine the type of input with a sneak-peek at the first element
  if (typeof(processed_spectra[[1]]) == "character") {
    if (is_a_rds_list(processed_spectra)) {
      processed <- lapply(processed_spectra, readRDS)
    }
  } else {
    processed <- processed_spectra
  }

  stopifnot(is_a_processed_spectra_list(processed))

  peakless <- list()
  # List the spectra with no peaks detected and remove them
  if (remove_peakless_spectra) {
    peakless <- lapply( # Extract the metadata object from all element of the list
      processed, `[[`, "metadata"
    ) %>%
      lapply(function(mdata) {
        rownames(mdata)[mdata$peaks == 0]
      }) %>%
      unlist()
    if (length(peakless) > 0) {
      warning(
        "No peaks were detected in the following spectra, so they will be removed\n",
        paste(peakless, collapse = "\n"), "\n"
      )
    }
  }

  # 7. Bin peaks
  peaks <- lapply( # Extract the peaks object from all element of the list
    processed, `[[`, "peaks"
  ) %>% unlist()
  names_spectra <- names(peaks)
  if (remove_peakless_spectra & length(peakless) > 0) {
    peaks <- peaks[-which(names(peaks) %in% peakless)]
  }
  peaks <- MALDIquant::binPeaks(peaks, tolerance = .002, method = "strict")

  # 8. Feature matrix construction (peaks as columns and spectra as rows)
  if (interpolate_missing) {
    # This is the default in the Strejcek et al. (2018) procedure
    spectra_list <- lapply( # Extract the spectrum object from all element of the list
      processed, `[[`, "spectra"
    ) %>% unlist()

    if (remove_peakless_spectra & length(peakless) > 0) {
      spectra_list <- spectra_list[-which(names(spectra_list) %in% peakless)]
    }
    featureMatrix <- MALDIquant::intensityMatrix(peaks, spectra_list)
  } else {
    featureMatrix <- MALDIquant::intensityMatrix(peaks)
    featureMatrix[is.na(featureMatrix)] <- 0
  }
  # Adding the correct rownames fto the matrix
  if (remove_peakless_spectra & length(peakless) > 0) {
    rownames(featureMatrix) <- names_spectra[-which(names_spectra %in% peakless)]
  } else {
    rownames(featureMatrix) <- names_spectra
  }
  return(featureMatrix)
}
```
  
```{r examples-merge_processed_spectra}
# Get an example directory of six Bruker MALDI Biotyper spectra
directory_biotyper_spectra <- system.file(
  "toy-species-spectra",
  package = "maldipickr"
)
# Import the six spectra
spectra_list <- import_biotyper_spectra(directory_biotyper_spectra)
# Transform the spectra signals according to Strejcek et al. (2018)
processed <- process_spectra(spectra_list)
# Merge the spectra to produce the feature matrix
fm <- merge_processed_spectra(list(processed))
# The feature matrix has 6 spectra as rows and
#  35 peaks as columns
dim(fm)
# Notice the difference when the interpolation is turned off
fm_no_interpolation <- merge_processed_spectra(
  list(processed),
  interpolate_missing = FALSE
)
sum(fm == 0) # 0
sum(fm_no_interpolation == 0) # 68

# Multiple runs can be aggregated using list()
# Merge the spectra to produce the feature matrix
fm_all <- merge_processed_spectra(list(processed, processed, processed))
# The feature matrix has 3×6=18 spectra as rows and
#  35 peaks as columns
dim(fm_all)
```
  
```{r tests-merge_processed_spectra}
directory_biotyper_spectra <- system.file("toy-species-spectra", package = "maldipickr")
spectra_list_test <- import_biotyper_spectra(directory_biotyper_spectra)[1:2]
processed_test <- process_spectra(spectra_list_test)
test_that("merge_processed_spectra works", {
  expect_equal(
    dim(merge_processed_spectra(list(processed_test))),
    c(2, 26)
  )
})
test_that("merge_processed_spectra fails with the wrong input", {
  expect_error(
    merge_processed_spectra(list()),
    "is not a list or it is an empty list."
  )
  expect_error(
    merge_processed_spectra("foo"),
    "is not a list or it is an empty list."
  )
})

test_that("merge_processed_spectra fails with only empty peaks", {
  expect_warning(
    empty_peaks <- list(
      createMassSpectrum(
        mass = 4500:5000,
        intensity = rep(0, 501),
        metaData = list(fullName = "foo")
      )
    ) %>% process_spectra(),
    "MassSpectrum object is empty!"
  )
  expect_warning(
    expect_error(
      list(empty_peaks) %>%
        merge_processed_spectra(),
      "no list of MALDIquant::MassPeaks objects!"
    ),
    "No peaks were detected in the following spectra, so they will be removed"
  )
})
```

## Compute a similarity matrix between all processed spectra (not included)

Once all the batches of spectra have been processed together, we can use a distance metric to evaluate how close the spectra are to one another.
[Strejcek *et al.* (2018)](https://doi.org/10.3389/fmicb.2018.01294) recommend the *cosine* metric to compare the spectra and they use the fast implementation in the [`{coop}`](https://cran.r-project.org/package=coop) package.

While we do not provide specific functions to generate the similarity matrix, we illustrate below how it can be easily computed.
Note that the feature matrix from [`merge_processed_spectra()`](https://clavellab.github.io/maldipickr/reference/merge_processed_spectra.html) has spectra as rows and peaks values as columns.
So to get a similarity matrix between spectra, either the feature matrix must be transposed or a dedicated function must be used.

```{r similarity, eval=FALSE}
# A. Compute the similarity matrix on the transposed feature matrix
#   using Pearson correlation coefficient
sim_matrix <- stats::cor(t(fm), method = "pearson")

# B.1 Install the coop package
# install.packages("coop")

# B.2 Compute the similarity matrix on the rows of the feature matrix
sim_matrix <- coop::tcosine(fm)
```

# Delineate clusters of spectra

## From a similarity matrix

### Similarity to clusters

When the similarity matrix is computed between all pairs of the studied spectra, the next step is to delineate clusters of spectra in order to dereplicate the measured bacterial colonies, that is to find which are nearly identical colonies.

The [`delineate_with_similarity()`](https://clavellab.github.io/maldipickr/reference/delineate_with_similarity.html) is agnostic of the similarity metric used provided that the upper bound is one and that a numeric threshold relevant to the metric used is given. We recommend the cosine metric or the Pearson product moment.

Hierarchical clustering will then group spectra in the same cluster only if the similarity between the spectra is **above** (or **equal to**) the provided threshold.
The default and recommended method is the _complete linkage_, also known as the farthest neighbor, to ensure that the within-group minimum similarity of each cluster respects the threshold.

Finally, a table summarizes for each spectra, to which cluster number it was assigned to and the size of the cluster, which is the total number of spectra in the cluster.


```{r function-delineate_with_similarity, filename = "delineate_with_similarity"}
#' Delineate clusters from a similarity matrix
#'
#' From a matrix of spectra similarity (e.g., with the cosine metric,
#' or Pearson product moment), infer the species clusters based on a
#' threshold **above** (or **equal to**) which spectra are considered alike.
#'
#' @param sim_matrix A \eqn{n \times n} similarity matrix, with \eqn{n} the number of spectra. Columns should be named as the rows.
#' @param threshold A numeric value indicating the minimal similarity between two spectra. Adjust accordingly to the similarity metric used.
#' @param method The method of hierarchical clustering to use. The default and recommended method is "complete", but any methods from [stats::hclust] are valid.
#'
#' @return A tibble of \eqn{n} rows for each spectra and 3 columns:
#' * `name`: the rownames of the similarity matrix indicating the spectra names
#' * `membership`: integers stating the cluster number to which the spectra belong to. It starts from 1 to \eqn{c}, the total number of clusters.
#' * `cluster_size`: integers indicating the total number of spectra in the corresponding cluster.
#'
#' @details The similarity matrix is converted to a distance matrix by subtracting the value one. This approach works for cosine similarity and positive correlations that have an upper bound of 1. Clusters are then delineated using hierarchical clustering. The default method of hierarchical clustering is the complete linkage (also known as farthest neighbor clustering) to ensure that the within-group minimum similarity of each cluster respects the threshold. See the Details section of [stats::hclust] for others valid methods to use.
#' 
#' @seealso For similarity metrics: [`coop::tcosine`](https://rdrr.io/cran/coop/man/cosine.html), [`stats::cor`](https://rdrr.io/r/stats/cor.html), [`Hmisc::rcorr`](https://rdrr.io/cran/Hmisc/man/rcorr.html). For using taxonomic identifications for clusters : [delineate_with_identification]. For further analyses: [set_reference_spectra].
#' @export
delineate_with_similarity <- function(sim_matrix, threshold, method = "complete") {
  if (!is.matrix(sim_matrix)) {
    stop("The similarity matrix is not a matrix.")
  }
  if (nrow(sim_matrix) != ncol(sim_matrix)) {
    stop("The similarity matrix is not square: nrow != ncol.")
  }
  if (is.null(rownames(sim_matrix)) || is.null(colnames(sim_matrix))) {
    stop("The similarity matrix has no rownames or colnames.")
  }
  if (any(rownames(sim_matrix) != colnames(sim_matrix))) {
    stop("The similarity matrix has no identical names.")
  }
  if (!is.numeric(threshold)) {
      stop("The threshold provided is not a numeric.")
  }
  if( threshold < 0 | threshold > 1 ){
    stop("The threshold provided is not in the range [0-1].")
  }
  
  # Clustering with default complete-linkage after
  #  conversion of similarity matrix to distance matrix
  #
  # WARNING: despite being distance agnostic, we expect the distance to be [0,1]
  dist_matrix <- stats::as.dist(1 - sim_matrix)
  hierarchical_clustering <- stats::hclust(dist_matrix, method = method)
  
  # Spectra belongs to the same cluster only if similarity is above or equal to the threshold
  #
  # The threshold is converted to a distance threshold
  dist_threshold <- 1 - threshold
  memberships <- stats::cutree(hierarchical_clustering, h = dist_threshold)


  memberships %>%
    tibble::enframe(value = "membership") %>%
    dplyr::group_by(.data$membership) %>%
    dplyr::mutate(
      "membership" = base::as.integer(.data$membership),
      "cluster_size" = dplyr::n()
    ) %>%
    dplyr::ungroup() %>%
    return()
}
```
  
```{r examples-delineate_with_similarity}
# Toy similarity matrix between the six example spectra of
#  three species. The cosine metric is used and a value of
#  zero indicates dissimilar spectra and a value of one
#  indicates identical spectra.
cosine_similarity <- matrix(
  c(
    1, 0.79, 0.77, 0.99, 0.98, 0.98,
    0.79, 1, 0.98, 0.79, 0.8, 0.8,
    0.77, 0.98, 1, 0.77, 0.77, 0.77,
    0.99, 0.79, 0.77, 1, 1, 0.99,
    0.98, 0.8, 0.77, 1, 1, 1,
    0.98, 0.8, 0.77, 0.99, 1, 1
  ),
  nrow = 6,
  dimnames = list(
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    ),
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    )
  )
)
# Delineate clusters based on a 0.92 threshold applied
#  to the similarity matrix
delineate_with_similarity(cosine_similarity, threshold = 0.92)
```

```{r tests-delineate_with_similarity}
cosine_similarity <- matrix(
  c(
    1, 0.79, 0.77, 0.99, 0.98, 0.98,
    0.79, 1, 0.98, 0.79, 0.8, 0.8,
    0.77, 0.98, 1, 0.77, 0.77, 0.77,
    0.99, 0.79, 0.77, 1, 1, 0.99,
    0.98, 0.8, 0.77, 1, 1, 1,
    0.98, 0.8, 0.77, 0.99, 1, 1
  ),
  nrow = 6,
  dimnames = list(
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    ),
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    )
  )
)
cosine_similarity_toy <- matrix(
  c(1.00, 0.92, 0.80,
    0.92, 1.00, 0.94,
    0.80, 0.94, 1.00),
  nrow = 3, byrow = TRUE,
  dimnames = rep(
    list(c("A", "B", "C")),
    times = 2)
)
test_that("delineate_with_similarity works", {
  expect_equal(
    nrow(delineate_with_similarity(cosine_similarity, 0.92)), 6
  )
  expect_equal(
    delineate_with_similarity(cosine_similarity, 0.92)$membership,
    c(1, 2, 2, 1, 1, 1)
  )
})
test_that("delineate_with_similarity works with different linkage", {
  expect_equal(
    delineate_with_similarity(
      cosine_similarity_toy, 0.92, method = "complete"
    )$membership,
    c(1, 2, 2)
  )
    expect_equal(
    delineate_with_similarity(
      cosine_similarity_toy, 0.92, method = "single"
    )$membership,
    c(1, 1, 1)
  )
})
test_that("delineate_with_similarity fails with wrong input", {
  expect_error(
    delineate_with_similarity(cosine_similarity[, -1], 0.92),
    "not square"
  )
  expect_error(
    delineate_with_similarity(unname(cosine_similarity), 0.92),
    "no rownames or colnames."
  )
  expect_error(
    delineate_with_similarity(cosine_similarity, TRUE),
    "not a numeric"
  )
  expect_error(
    delineate_with_similarity(cosine_similarity, 2.5),
    "not in the range"
  )
  expect_error(
    delineate_with_similarity(cosine_similarity, 0.92, method = "farthest"),
    "invalid clustering method"
  )
})
```

### Set a reference spectrum for each cluster

Once the table of clusters is generated from the similarity matrix, a reference spectrum can be assigned to each cluster.

We choose to define high-quality spectra as representative spectra of the clusters using internal information. That is, representative spectra have, within their cluster, the highest median signal-to-noise ratio and then the highest number of detected peaks.

The function [`set_reference_spectra()`](https://clavellab.github.io/maldipickr/reference/set_reference_spectra.html) does not change the order of the cluster table but merely adds an additional column `is_reference` to indicate whether the corresponding spectrum is representative of the cluster. 
    
```{r function-set_reference_spectra, filename="set_reference_spectra"}
#' Set a reference spectrum for each cluster
#'
#' Define a high-quality spectra as a representative
#' spectra of the cluster based on the highest median signal-to-noise ratio
#' and the number of detected peaks
#'
#'
#' @param cluster_df A tibble of *n* rows for each spectra produced by [delineate_with_similarity] function with at least the following columns:
#' * `name`: the rownames of the similarity matrix indicating the spectra names
#' * `membership`: integers stating the cluster number to which the spectra belong to. It starts from 1 to _c_, the total number of clusters.
#' * `cluster_size`: integers indicating the total number of spectra in the corresponding cluster.
#' @param metadata_df A tibble of *n* rows for each spectra produced by the [process_spectra] function with median signal-to-noise ratio (`SNR`), peaks number (`peaks`), and spectra names in the `name` column.
#'
#'
#' @return A merged tibble in the same order as `cluster_df` with both the columns of `cluster_df` and `metadata_df`, as well as a logical column `is_reference` indicating if the spectrum is the reference spectra of the cluster.
#'
#' @seealso [delineate_with_similarity], [pick_spectra]
#'
#' @export
set_reference_spectra <- function(cluster_df, metadata_df) {
  # Checking the tibbles sizes
  if (base::nrow(cluster_df) != base::nrow(metadata_df)) {
    stop(
      "The tibbles do not have the same number of rows!",
      "Note: if multiple batches are included in 'cluster_df'",
      "consider combining the multiple associated metadata tables",
      "using 'dplyr::bind_rows()'."
    )
  }
  # Checking the tibbles columns
  if (any(!c("name", "membership", "cluster_size") %in% colnames(cluster_df))) {
    stop(
      "'cluster_df' lacks one of the following columns:",
      "name, membership, cluster_size"
    )
  }
  if (any(!c("name", "SNR", "peaks") %in% colnames(metadata_df))) {
    stop(
      "'metadata_df' lacks one of the following columns:",
      "name, SNR, peaks"
    )
  }
  # Merging cluster information and spectra/peaks metadata to select the
  # reference spectra
  cluster_df %>%
    # Keep track of the row order via a numeric id
    tibble::rowid_to_column() %>%
    dplyr::inner_join(metadata_df, by = "name") %>%
    # Make sure the sorting is done within groups
    dplyr::group_by(.data$membership) %>%
    dplyr::arrange(dplyr::desc(.data$SNR), dplyr::desc(.data$peaks), .by_group = TRUE) %>%
    # first() gives the name of the spectra so needs for an
    # extra step to convert to a logical vector
    dplyr::mutate(
      "is_reference" = dplyr::first(.data$name),
      "is_reference" = .data$is_reference == .data$name
    ) %>%
    dplyr::ungroup() %>%
    # Sort the tibble in the original order
    dplyr::arrange(.data$rowid) %>%
    dplyr::select(-c("rowid")) %>%
    return()
}
```
  
```{r examples-set_reference_spectra}
# Get an example directory of six Bruker MALDI Biotyper spectra
# Import the six spectra and
# Transform the spectra signals according to Strejcek et al. (2018)
processed <- system.file(
  "toy-species-spectra",
  package = "maldipickr"
) %>%
  import_biotyper_spectra() %>%
  process_spectra()

# Toy similarity matrix between the six example spectra of
#  three species. The cosine metric is used and a value of
#  zero indicates dissimilar spectra and a value of one
#  indicates identical spectra.
cosine_similarity <- matrix(
  c(
    1, 0.79, 0.77, 0.99, 0.98, 0.98,
    0.79, 1, 0.98, 0.79, 0.8, 0.8,
    0.77, 0.98, 1, 0.77, 0.77, 0.77,
    0.99, 0.79, 0.77, 1, 1, 0.99,
    0.98, 0.8, 0.77, 1, 1, 1,
    0.98, 0.8, 0.77, 0.99, 1, 1
  ),
  nrow = 6,
  dimnames = list(
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    ),
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    )
  )
)
# Delineate clusters based on a 0.92 threshold applied
#  to the similarity matrix
clusters <- delineate_with_similarity(
  cosine_similarity,
  threshold = 0.92
)

# Set reference spectra with the toy example
set_reference_spectra(clusters, processed$metadata)
```
  
```{r tests-set_reference_spectra}
processed <- system.file("toy-species-spectra", package = "maldipickr") %>%
  import_biotyper_spectra() %>%
  process_spectra()
cosine_similarity <- matrix(
  c(
    1, 0.79, 0.77, 0.99, 0.98, 0.98,
    0.79, 1, 0.98, 0.79, 0.8, 0.8,
    0.77, 0.98, 1, 0.77, 0.77, 0.77,
    0.99, 0.79, 0.77, 1, 1, 0.99,
    0.98, 0.8, 0.77, 1, 1, 1,
    0.98, 0.8, 0.77, 0.99, 1, 1
  ),
  nrow = 6,
  dimnames = list(
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    ),
    c(
      "species1_G2", "species2_E11", "species2_E12",
      "species3_F7", "species3_F8", "species3_F9"
    )
  )
)
clusters <- delineate_with_similarity(cosine_similarity, threshold = 0.92)
test_that("set_reference_spectra works", {
  expect_equal(
    set_reference_spectra(clusters, processed$metadata)$is_reference,
    c(FALSE, FALSE, TRUE, FALSE, TRUE, FALSE)
  )
})
test_that("set_reference_spectra fails with inadequate metadata", {
  expect_error(
    set_reference_spectra(clusters, processed$metadata[1:2, ]),
    "The tibbles do not have the same number of rows!"
  )
  expect_error(
    set_reference_spectra(clusters[, -2], processed$metadata),
    "lacks one of the following columns"
  )
  expect_error(
    set_reference_spectra(clusters, processed$metadata[, -2]),
    "lacks one of the following columns"
  )
})
```
  

## From taxonomic identifications

An alternative to the similarity matrix approach from the previous section is to rely on the taxonomic identification of the spectra to delineate clusters.
To do so, we must use the Bruker MALDI Biotyper report from the Compass software that summarize the identification of the microorganisms using its internal database. Once the report or reports are imported (in R using [`read_biotyper_report()`](https://clavellab.github.io/maldipickr/reference/read_biotyper_report.html)), the function [`delineate_with_identification()`](https://clavellab.github.io/maldipickr/reference/delineate_with_identification.html) will group spectra based on their identifications.


```{r function-delineate_with_identification}
#' Delineate clusters from taxonomic identifications
#'
#' From the report of taxonomic identification produced by the Bruker MALDI Biotyper
#' spectra sharing the same identification are labeled in the same cluster.
#' Spectra with unknown identification (e.g., due to database completeness) are set in unique cluster.
#'
#' @param tibble_report A tibble of *n* rows, with *n* the number of spectra,
#' produced by [read_biotyper_report()] or [read_many_biotyper_reports()]. The long format and the best hits options are expected to be used in these functions to produce a compliant input tibble.
#'
#' @details As all unknown identification are considered unique clusters _within one input tibble_, it is important to consider whether the taxonomic identifications come from a single report or multiple reports, depending on the research question. A message is displayed to confirm from which type of reports the delineation was done.
#'
#' @return A tibble of *n* rows for each spectra and 3 columns:
#' * `name`: the spectra names from the `name` column from the output of either [read_biotyper_report()] or [read_many_biotyper_reports()].
#' * `membership`: integers stating the cluster number to which the spectra belong to. It starts from 1 to _c_, the total number of clusters.
#' * `cluster_size`: integers indicating the total number of spectra in the corresponding cluster.
#'
#' @seealso [delineate_with_similarity]
#'
#' @export
delineate_with_identification <- function(tibble_report) {
  # check correct names and number of columns
  single_report_cols <- c(
    "name", "sample_name",
    "hit_rank", "bruker_quality",
    "bruker_species", "bruker_taxid",
    "bruker_hash", "bruker_log"
  )
  many_reports_cols <- c(
    "name",
    gsub("^name$", "original_name", single_report_cols)
  )
  if (identical(
    base::colnames(tibble_report),
    single_report_cols
  )) {
    message("Generating clusters from single report")
    id_column <- single_report_cols[1]
  } else if (identical(
    base::colnames(tibble_report),
    many_reports_cols
  )) {
    message("Generating clusters from multiple reports")
    id_column <- many_reports_cols[1]
  } else {
    stop(
      "Unexpected format of Biotyper report.\n",
      "  Please ensure the report is imported in R correctly with either:\n",
      "    - `read_biotyper_report(long_format = TRUE)`\n",
      "    - `read_many_biotyper_reports()`"
    )
  }

  # Checking that best_hits = TRUE was used
  n_target_names <- dplyr::pull(tibble_report, {{ id_column }}) %>% dplyr::n_distinct()
  if (n_target_names != nrow(tibble_report)) {
    warning(
      "There is more than one spectrum identification per target!\n",
      "  Did you forget to use best_hits = TRUE or to filter the hits beforehand?"
    )
  }

  # Make unknown identification unique
  tibble_report %>%
    dplyr::mutate(
      "membership" = dplyr::if_else(
        .data$bruker_species == "not reliable identification",
        make.unique(.data$bruker_species),
        .data$bruker_species
      ),
      "membership" = as.integer(as.factor(.data$membership))
    ) %>%
    dplyr::group_by(.data$membership) %>%
    dplyr::mutate(
      "cluster_size" = dplyr::n()
    ) %>%
    dplyr::ungroup() %>%
    dplyr::select(
      c(
        {{ id_column }}, "membership", "cluster_size"
      )
    ) %>%
    return()
}
```
  
```{r example-delineate_with_identification}
report_unknown <- read_biotyper_report(
  system.file("biotyper_unknown.csv", package = "maldipickr")
)
delineate_with_identification(report_unknown)
```
  
```{r tests-delineate_with_identification}
path_report <- system.file("biotyper_unknown.csv", package = "maldipickr")
report_unknown <- read_biotyper_report(path_report)

test_that("delineate_with_identification fails with path as input", {
  expect_error(
    delineate_with_identification(path_report),
    "Unexpected format of Biotyper report."
  )
})
test_that("delineate_with_identification works with correct single report tibble", {
  expect_message(
    out <- delineate_with_identification(report_unknown),
    "Generating clusters from single report"
  )
  expect_equal(
    nrow(out), 4
  )
  expect_equal(
    out$membership,
    c(2, 3, 1, 1)
  )
})

test_that("delineate_with_identification fails modified single report tibble", {
  expect_error(
    delineate_with_identification(
      report_unknown %>% dplyr::select(!c("name"))
    ),
    "Unexpected format of Biotyper report."
  )
})

report_unknown_no_bh <- read_biotyper_report(path_report, best_hits = FALSE)
test_that("delineate_with_identification WARNS when multiple hits", {
  expect_warning(
    out <- delineate_with_identification(report_unknown_no_bh),
    "There is more than one spectrum identification per target!\n",
  )
  expect_equal(
    nrow(out), 40
  )
  expect_equal(
    out$cluster_size,
    c(
      rep(1, times = 20),
      5, 5, rep(1, times = 8),
      5, 5, 5, rep(1, times = 7)
    )
  )
})


# Artificially generate multiple reports from one
multiple_reports_unknown <- read_many_biotyper_reports(
  rep(path_report, 3),
  report_ids = LETTERS[1:3], best_hits = TRUE
)
test_that("delineate_with_identification works with correct multiple reports tibble", {
  expect_message(
    out <- delineate_with_identification(multiple_reports_unknown),
    "Generating clusters from multiple reports"
  )
  expect_equal(
    nrow(out), 12
  )
  expect_equal(
    out$membership,
    c(2, 3, 1, 1, 4, 5, 1, 1, 6, 7, 1, 1)
  )
})
test_that("delineate_with_identification fails modified tibble for multiple reports", {
  expect_error(
    delineate_with_identification(multiple_reports_unknown %>% dplyr::rename("tax_id" = "bruker_species")),
    "Unexpected format of Biotyper report."
  )
})
```
  
Clusters generated from taxonomic identifications can not use the function [`set_reference_spectra()`](https://clavellab.github.io/maldipickr/reference/set_reference_spectra.html) as the latter relies on peaks information that is not disclosed in the Biotyper report.

Therefore, users interested in cherry-picking spectra using taxonomic identifications should use the [`pick_spectra()`](https://clavellab.github.io/maldipickr/reference/pick_spectra.html) function described below with the combination of the input and output tables of the [`delineate_with_identification()`](https://clavellab.github.io/maldipickr/reference/delineate_with_identification.html) function to pick for instance spectra with the highest log score (using `criteria_column = "bruker_log"`).
  
## Import clusters results generated by SPeDE

Raw spectra can also be processed and clustered by another approach, named [`SPeDE`](https://doi.org/10.1128/mSystems.00437-19), developed by Dumolin et al. (2019).
The resulting dereplication step produces a comma separated table. The example below illustrates how to import this table into R to be consistent with the dereplication table generated within the [`{maldipickr}`](https://github.com/ClavelLab/maldipickr) package.
    
```{r function-import_spede_clusters}
#' Import clusters results generated by SPeDE
#'
#' Reformat the table output from the analysis of raw Bruker MALDI Biotyper
#' spectra by the SPeDE tool from Dumolin et al. (2019) to be consistent with the Strejcek et al. (2018) procedure followed
#' in the [maldipickr] package.
#'
#' @param path Path to the comma separated table generated by SPeDE
#'
#' @return A tibble with the following columns:
#'
#' * `name`: a character denoting the spectra name (all spaces, dashes and dots are replaced by underscores "_" in SPeDE)
#' * `membership`: integers stating the cluster number to which the spectra belong to. It starts from 1 to _c_, the total number of clusters.
#' * `cluster_size`: integers indicating the total number of spectra in the corresponding cluster.
#' * `quality`: a character indicating the spectra quality category by SPeDE, out of GREEN, ORANGE and RED.
#' * `is_reference`: a logical indicating whether the corresponding spectra is a reference spectra of the cluster.
#'
#' @seealso <https://github.com/LM-UGent/SPeDE>
#' @references Dumolin C, Aerts M, Verheyde B, Schellaert S, Vandamme T, Van Der Jeugt F, De Canck E, Cnockaert M, Wieme AD, Cleenwerck I, Peiren J, Dawyndt P, Vandamme P, & Carlier A. (2019). "Introducing SPeDE: High-Throughput Dereplication and Accurate Determination of Microbial Diversity from Matrix-Assisted Laser Desorption–Ionization Time of Flight Mass Spectrometry Data". *MSystems* 4(5). <doi:10.1128/msystems.00437-19>.
#' @export
import_spede_clusters <- function(path) {
  # Import the SPeDE csv table with only the columns planned to be used
  utils::read.csv(path) %>%
    dplyr::select(
      "SOURCE_FILE",
      "QUALITY",
      "REFERENCE",
      "REFERENCE_NUMBER"
    ) %>%
    # Discard the trailing "Not matched:" and  "Rejected spectra:" at the end of the csv
    dplyr::filter(!is.na(.data$REFERENCE_NUMBER)) %>%
    tibble::as_tibble() %>%
    # Sanitize the column names and variable types to the package convention
    dplyr::rename(c(
      "name" = "SOURCE_FILE",
      "membership" = "REFERENCE_NUMBER",
      "quality" = "QUALITY"
    )) %>%
    dplyr::mutate(
      "membership" = .data$membership + 1,
      "is_reference" = if_else(.data$REFERENCE == "Yes", TRUE, FALSE)
    ) %>%
    # Add the cluster_size
    dplyr::group_by(.data$membership) %>%
    dplyr::mutate("cluster_size" = dplyr::n()) %>%
    dplyr::select("name", "membership", "cluster_size", "quality", "is_reference") %>%
    dplyr::ungroup() %>%
    return()
}
```
  
```{r examples-import_spede_clusters}
# Reformat the output from SPeDE table
# https://github.com/LM-UGent/SPeDE
import_spede_clusters(
  system.file("spede.csv", package = "maldipickr")
)
```
  
```{r tests-import_spede_clusters}
test_that("import_spede_clusters works", {
  expect_equal(
    nrow(import_spede_clusters(
      system.file("spede.csv", package = "maldipickr")
    )), 6
  )
})
test_that("import_spede_clusters is empty when no spectra where matched", {
  expect_equal(
    nrow(import_spede_clusters(
      system.file("spede-empty.csv", package = "maldipickr")
    )), 0
  )
})
```


# Cherry-pick Bruker MALDI Biotyper spectra
    
When isolating bacteria from an environment, experimenters want to be thorough but also work-, time- and cost-savvy. One approach is to reduce the redundancy of the bacterial isolates by analyzing their MALDI-TOF spectra from the Bruker Biotyper. All the steps previously described in this vignette consisted of processing the spectra to be able to pick only non-redundant spectra, using the [`pick_spectra()`](https://clavellab.github.io/maldipickr/reference/pick_spectra.html) function.

The function, as illustrated in the examples below, can pick spectra using different types of inputs:

* the reference spectra information that is present in the cluster table (after using [`delineate_with_similarity()`](https://clavellab.github.io/maldipickr/reference/delineate_with_similarity.html) or [`import_spede_clusters()`](https://clavellab.github.io/maldipickr/reference/import_spede_clusters.html) functions; see example 1)
* an external metadata table containing a variable (e.g., optical density, fluorescence) to be maximized (default) or minimized per cluster (see example 2)

Spectra, and clusters, can also be excluded from the cherry-picking decision, a procedure termed _masking_ here. We distinguish two types of mask that are implemented in the [`pick_spectra()`](https://clavellab.github.io/maldipickr/reference/pick_spectra.html) function:

* **soft mask** that discards the spectra only, if they correspond for instance to low-quality sample, negative control samples (see example 3)
* **hard mask** that discards the spectra _and their clusters_ (see example 4). This is particularly useful if some spectra have been previously picked. For instance, to exclude colonies grown and picked 24h after streaking when comparing with colonies grown for 72h.

Advanced users can also provide directly a cluster table with a custom sort by cluster to accommodate complex design.

Ultimately, the function delivers a table with as many rows as the cluster table with an additional logical column named `to_pick` to indicate whether the colony associated with the spectra should be picked (`TRUE`) or not picked (`FALSE`).

    
```{r function-pick_spectra}
#' Cherry-pick Bruker MALDI Biotyper spectra
#'
#' Using the clusters information, and potential additional metadata as external
#' criteria, spectra are labeled as to be picked for each cluster. Note that some
#' spectra and therefore clusters can be explicitly removed (_masked_)
#' from the picking decision if they have been previously picked
#' or should be discarded, using logical columns in the metadata table.
#' If no metadata are provided, the reference spectra of each cluster will be picked.
#'
#' @param cluster_df A tibble with clusters information
#' from the [delineate_with_similarity] or the [import_spede_clusters] function.
#' @param metadata_df Optional tibble with relevant metadata to guide the
#' picking process (e.g., OD600).
#' @param criteria_column Optional character indicating the column in `metadata_df`
#' to be used as a criteria.
#' @param hard_mask_column Column name in the `cluster_df` or `metadata_df` tibble indicating whether the spectra, **and the clusters to which they belong** should be discarded (`TRUE`) or not (`FALSE`) before the picking decision.
#' @param soft_mask_column Column name in the `cluster_df` or `metadata_df` tibble indicating whether the spectra should be discarded (`TRUE`) or not (`FALSE`) before the picking decision.
#' @param is_descending_order Optional logical indicating whether to sort the `criteria_column` from the highest-to-lowest value (`TRUE`) or lowest-to-highest (`FALSE`).
#' @param is_sorted Optional logical to indicate that the `cluster_df` is
#' already sorted by cluster based on (usually multiple) internal criteria to
#' pick the first of each cluster. This flag is **overridden** if a `metadata_df`
#' is provided.
#'
#' @return A tibble with as many rows as `cluster_df` with an additional logical
#' column named `to_pick` to indicate whether the colony associated to the spectra
#' should be picked. If `metadata_df` is provided, then additional columns from
#' this tibble are added to the returned tibble.
#'
#' @seealso [delineate_with_similarity], [set_reference_spectra]. For a useful utility function to soft-mask specific spectra: [is_well_on_edge].
#'
#' @export
pick_spectra <- function(
    cluster_df,
    metadata_df = NULL, criteria_column = NULL,
    hard_mask_column = NULL, soft_mask_column = NULL,
    is_descending_order = TRUE,
    is_sorted = FALSE) {
  # Check that:
  #  - the mandatory column describing the cluster are present
  #  - clusters have a reference spectra to be picked if no metadata are provided
  #  - when metadata (resp. a criteria column) is provided,
  #     a criteria column (resp. metadata) should be provided as well
  #  - when masking columns are indicated, the metadata tibble should be added
  #  - the spectra name in the metadata table are also present in the clusters table
  if (any(!c("name", "membership") %in% colnames(cluster_df))) {
    stop(
      "'cluster_df' lacks one of the following columns: name or membership"
    )
  }
  if (is.null(metadata_df) & !"is_reference" %in% colnames(cluster_df)) {
    stop(
      "No additional metadata are provided ('metadata_df' tibble is NULL)",
      " and there is no 'is_reference' column in the 'cluster_df' tibble.\n",
      "Please do one of the following strategy:\n",
      "    1. Either run the 'set_reference_spectra' or 'import_spede_clusters'",
      "       function beforehand to indicate a reference spectra\n",
      "    2. Provide a 'metadata' tibble\n"
    )
  }
  if (
    (!is.null(metadata_df) & is.null(criteria_column)) ||
      (is.null(metadata_df) & !is.null(criteria_column))
  ) {
    stop(
      "Additional metadata ('metadata_df' tibble) should be provided",
      " with a criteria column ('criteria_column') to be sorted.",
      "Please provide the two together."
    )
  }
  if (
    (is.null(metadata_df) & !is.null(hard_mask_column)) ||
      (is.null(metadata_df) & !is.null(soft_mask_column))
  ) {
    stop(
      "Masking column(s) ('hard'/'soft') require an additional",
      " metadata ('metadata_df')"
    )
  }
  if (any(!metadata_df$name %in% cluster_df$name)) {
    stop(
      "The spectra names in the metadata ('metadata_df' tibble) table",
      " do not match the names in the clusters table ('cluster_df')."
    )
  }
  # Warn that metadata table are prioritize over the 'is_sorted' flag
  if (is_sorted & !is.null(metadata_df)) {
    message(
      "The 'is_sorted' flag is set to TRUE, while a metadata table is",
      " provided. ",
      "Please note that the metadata table takes precedence and the cherry-picking",
      " step will rely on the 'criteria_column'."
    )
    # Set the flag to FALSE for consistency
    is_sorted <- FALSE
  }

  # Preparing the table by merging with the metadata if present
  #   and checking the presence of the columns

  # Keep the initial order of the rows
  cluster_df <- tibble::rowid_to_column(cluster_df, "rowid")
  # And a copy of the unchanged data.frame
  # orig_cluster_df <- dplyr::select(cluster_df, c("rowid", "name"))
  orig_cluster_df <- cluster_df

  if (!is.null(metadata_df)) {
    cluster_df <- cluster_df %>%
      dplyr::left_join(metadata_df, by = "name")
    # Update the copy of the unchanged data.frame
    orig_cluster_df <- cluster_df
    if (!is.null(criteria_column) & !criteria_column %in% colnames(cluster_df)) {
      stop(
        "The 'criteria_column' is not present in the merged tibble."
      )
    }
    if (!is.null(soft_mask_column)) {
      if (!soft_mask_column %in% colnames(cluster_df)) {
        stop(
          "The 'soft_mask_column' is not present in the merged tibble."
        )
      }
    }
    if (!is.null(hard_mask_column)) {
      if (!hard_mask_column %in% colnames(cluster_df)) {
        stop(
          "The 'hard_mask_column' is not present in the merged tibble."
        )
      }
    }

    # Hard mask: discard the spectra *and* their clusters
    # Soft mask: discard the spectra only

    # Soft mask
    if (!is.null(soft_mask_column)) {
      cluster_df <- cluster_df %>% filter(!.data[[soft_mask_column]])
    }
    # Hard masking is used to label a group that should be
    # discarded in the dereplication process and not be chosen
    # from:
    #  e.g. 24h in the 24h vs 48h comparison
    #  e.g. fast in the fast vs slow growers comparison
    if (!is.null(hard_mask_column)) {
      clusters_to_keep <- cluster_df %>%
        dplyr::select(tidyselect::all_of(c("membership", hard_mask_column))) %>%
        # Internally, we will label the clusters to be kept,
        #  meaning the clusters that:
        #   do NOT contain spectra from the discard group
        #   AND contain only spectra from one group (either all discard, or all keep)
        dplyr::distinct() %>%
        dplyr::add_count(.data$membership) %>%
        dplyr::filter(n == 1 & !.data[[hard_mask_column]]) %>%
        dplyr::pull(.data$membership)

      # Remove the clusters where picking is forbidden
      cluster_df <- dplyr::filter(cluster_df, .data$membership %in% clusters_to_keep)
    }
  }


  # Sort the spectra within each cluster using the provided metadata
  if (!is.null(metadata_df) & !is_sorted) {
    cluster_df <- cluster_df %>%
      dplyr::group_by(.data$membership)
    if (is_descending_order) {
      cluster_df <- dplyr::arrange(
        cluster_df, dplyr::desc(.data[[criteria_column]]),
        .by_group = TRUE
      )
    } else {
      cluster_df <- dplyr::arrange(
        cluster_df, .data[[criteria_column]],
        .by_group = TRUE
      )
    }
  }

  # Pick the reference spectra if no metadata are present
  if (is.null(metadata_df)) {
    cluster_df <- cluster_df %>%
      dplyr::mutate(
        "to_pick" = .data$is_reference
      )
  } else {
    # first() gives the name of the spectra so needs for an
    # extra step to convert to a logical vector
    cluster_df <- cluster_df %>%
      dplyr::mutate(
        "to_pick" = dplyr::first(.data$name),
        "to_pick" = .data$to_pick == .data$name
      )
  }
  # Merge with original tibble to keep potential masked/discarded spectra
  # and same row number and order
  # NA in 'to_pick' are replaced with FALSE in the case of discarded clusters

  cols <- base::intersect(
    colnames(cluster_df),
    colnames(orig_cluster_df)
  )
  cluster_df %>%
    dplyr::ungroup() %>%
    dplyr::right_join(orig_cluster_df, by = cols) %>%
    dplyr::mutate(
      "to_pick" = tidyr::replace_na(.data$to_pick, FALSE)
    ) %>%
    # Sort the tibble in the original order
    dplyr::arrange(.data$rowid) %>%
    dplyr::select(-c("rowid")) %>%
    return()
}
```
  
```{r examples-pick_spectra}
# 0. Load a toy example of a tibble of clusters created by
#   the `delineate_with_similarity` function.
clusters <- readRDS(
  system.file("clusters_tibble.RDS",
    package = "maldipickr"
  )
)
# 1. By default and if no other metadata are provided,
#   the function picks reference spectra for each clusters.
#
# N.B: The spectra `name` and `to_pick` columns are moved to the left
# only for clarity using the `relocate()` function.
#
pick_spectra(clusters) %>%
  dplyr::relocate(name, to_pick) # only for clarity

# 2.1 Simulate OD600 values with uniform distribution
#  for each of the colonies we measured with
#  the Bruker MALDI Biotyper
set.seed(104)
metadata <- dplyr::transmute(
  clusters,
  name = name, OD600 = runif(n = nrow(clusters))
)
metadata

# 2.2 Pick the spectra based on the highest
#   OD600 value per cluster
pick_spectra(clusters, metadata, "OD600") %>%
  dplyr::relocate(name, to_pick) # only for clarity

# 3.1 Say that the wells on the right side of the plate are
#   used for negative controls and should not be picked.
metadata <- metadata %>% dplyr::mutate(
  well = gsub(".*[A-Z]([0-9]{1,2}$)", "\\1", name) %>%
    strtoi(),
  is_edge = is_well_on_edge(
    well_number = well, plate_layout = 96, edges = "right"
  )
)

# 3.2 Pick the spectra after discarding (or soft masking)
#   the spectra indicated by the `is_edge` column.
pick_spectra(clusters, metadata, "OD600",
  soft_mask_column = "is_edge"
) %>%
  dplyr::relocate(name, to_pick) # only for clarity

# 4.1 Say that some spectra were picked before
#   (e.g., in the column F) in a previous experiment.
# We do not want to pick clusters with those spectra
#   included to limit redundancy.
metadata <- metadata %>% dplyr::mutate(
  picked_before = grepl("_F", name)
)
# 4.2 Pick the spectra from clusters without spectra
#   labeled as `picked_before` (hard masking).
pick_spectra(clusters, metadata, "OD600",
  hard_mask_column = "picked_before"
) %>%
  dplyr::relocate(name, to_pick) # only for clarity
```
  
```{r tests-pick_spectra}
clusters <- readRDS(system.file("clusters_tibble.RDS", package = "maldipickr"))
set.seed(104)
metadata <- dplyr::transmute(clusters, name = name, OD600 = runif(n = nrow(clusters))) %>%
  dplyr::mutate(
    well = gsub(".*[A-Z]([0-9]{1,2}$)", "\\1", name) %>%
      strtoi(),
    is_edge = is_well_on_edge(
      well_number = well, plate_layout = 96, edges = "right"
    ),
    picked_before = grepl("_F", name)
  )
altered_metadata <- dplyr::mutate(metadata, name = gsub("species", "", name))
test_that("pick_spectra works", {
  expect_true(
    identical(
      pick_spectra(clusters)$is_reference,
      pick_spectra(clusters)$to_pick
    )
  )
  expect_equal(
    pick_spectra(clusters, metadata, "OD600")$to_pick,
    c(FALSE, TRUE, FALSE, TRUE, FALSE, FALSE)
  )
  expect_equal(
    pick_spectra(clusters, metadata, "OD600",
      is_descending_order = FALSE
    )$to_pick,
    c(FALSE, FALSE, TRUE, FALSE, FALSE, TRUE)
  )
  expect_equal(
    pick_spectra(clusters, metadata, "OD600",
      soft_mask_column = "is_edge"
    )$to_pick,
    c(FALSE, TRUE, FALSE, TRUE, FALSE, FALSE)
  )
  expect_equal(
    pick_spectra(clusters, metadata, "OD600",
      hard_mask_column = "picked_before"
    )$to_pick,
    c(FALSE, TRUE, FALSE, FALSE, FALSE, FALSE)
  )
  expect_equal(
    pick_spectra(clusters, is_sorted = TRUE)$to_pick,
    c(FALSE, FALSE, TRUE, FALSE, TRUE, FALSE)
  )
})
test_that("pick_spectra fails without metadata and column", {
  expect_error(
    pick_spectra(clusters[, -1]),
    "lacks one of the following columns"
  )
  expect_error(
    pick_spectra(clusters[, -6]),
    "No additional metadata are provided"
  )
  expect_error(
    pick_spectra(clusters, metadata),
    "Additional metadata"
  )
  expect_error(
    pick_spectra(clusters, altered_metadata, "OD600"),
    "The spectra names in the metadata"
  )
  expect_error(
    pick_spectra(clusters, metadata, "OD600",
      hard_mask_column = "NOT_IN_TIBBLE"
    ),
    "The 'hard_mask_column' is not present in the merged tibble."
  )
  expect_error(
    pick_spectra(clusters, hard_mask_column = "picked_before"),
    "Masking column"
  )
})
```
  

# References

* Dumolin C, Aerts M, Verheyde B, Schellaert S, Vandamme T, Van Der Jeugt F, De Canck E, Cnockaert M, Wieme AD, Cleenwerck I, Peiren J, Dawyndt P, Vandamme P, & Carlier A. (2019). "Introducing SPeDE: High-Throughput Dereplication and Accurate Determination of Microbial Diversity from Matrix-Assisted Laser Desorption–Ionization Time of Flight Mass Spectrometry Data". *MSystems* 4(5). <doi:10.1128/msystems.00437-19>.
* Strejcek M, Smrhova T, Junkova P & Uhlik O (2018). “Whole-Cell MALDI-TOF MS versus 16S rRNA Gene Analysis for Identification and Dereplication of Recurrent Bacterial Isolates.” *Frontiers in Microbiology* 9 <doi:10.3389/fmicb.2018.01294>.

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(
  flat_file = "dev/dereplicate-spectra.Rmd",
  vignette_name = "Dereplicate Bruker MALDI Biotyper spectra"
)
```
